program sncSeqRAM

%%// needed for calling seq_pvPut from embedded C code 
foreign ssId;

%%//----------------------------------------
%%//           Variables
%%//----------------------------------------

int eventNum = 63;
char device[40];
char * evPrefix = "Evt";
char * evCodeName = "Code";
char * evTimeNameRB = "DelayRaw-RB.RVAL";
char * evTimeNameSP = "DelayRaw-SP.RVAL";
char * evModeName = "DelayType-Sts";
char * evCtrlName = "Mode-Sts";
char str[40];
int i;
int numberOfWrites;
long seqram2[16384];
long seqram1[16384];

%%//----------------------------------------
%%//      State Machine Status PVs
%%//----------------------------------------

int StateMachineStatus;
assign StateMachineStatus to "{P}{R}STATEMACHINE";

%%//----------------------------------------
%%//         Monitored PVs
%%//----------------------------------------

int network;
assign network to "{P}{R}Network-Mon";
monitor network;

int EvtDelayVal;
assign EvtDelayVal to "{P}{R}EvtDelayMod.A";
monitor EvtDelayVal;

int EvtDelayNum;
assign EvtDelayNum to "{P}{R}EvtDelayMod.B";
monitor EvtDelayNum;

int EvtType;
assign EvtType to "{P}{R}EvtDelayMod.C";
monitor EvtType;

int EvtMode;
assign EvtMode to "{P}{R}EvtDelayMod.D";
monitor EvtMode;

int EvtDelayValL;

int EvtDelayNumL;

int EvtTypeL;

int EvtModeL;

int StatusEvt;
assign StatusEvt to "{P}{R}EvtSyncStatus-Mon";

%%// tbl MUST HAVE, at least, the same length of ITBL
int tbl[864];
assign tbl to "{P}{R}BucketList-SP";

int tbl_rbv[864];
assign tbl_rbv to "{P}{R}BucketList-Mon";

int tbl_rbv_proc;
assign tbl_rbv_proc to "{P}{R}BucketList-Mon.PROC";

int tbl_length;
assign tbl_length to "{P}{R}BucketListLen-Mon";
monitor tbl_length;

int tbl_diff;
assign tbl_diff to "{P}{R}BucketListSyncStatus-Mon";
monitor tbl_diff;

int seqs;
assign seqs to "{P}{R}SeqStatus-Mon";
monitor seqs;

int seqen_rbv;
assign seqen_rbv to "{P}{R}SeqEnbl-Sts";
monitor seqen_rbv;

int seqen;
assign seqen to "{P}{R}SeqEnbl-Sel";
int seqsw;
assign seqsw to "{P}{R}SeqSw-Cmd.PROC";
int seqaddr;
assign seqaddr to "{P}{R}SeqAddr-SP";
int seqcode;
assign seqcode to "{P}{R}SeqCode-SP";
int seqtime;
assign seqtime to "{P}{R}SeqTime-SP";

int seqcount;
assign seqcount to "{P}{R}SeqCount-SP";
monitor seqcount;

int seqcount_proc;
assign seqcount_proc to "{P}{R}SeqCount-SP.PROC";

int event_codes[63];
assign event_codes to {};

unsigned int event_timestampsRBID[63];

int event_timestampsRB[63];
assign event_timestampsRB to {};

unsigned int event_timestampsSPID[63];

int event_timestampsSP[63];
assign event_timestampsSP to {};

int event_modes[63];
assign event_modes to {};

int event_ctrl[63];
assign event_ctrl to {};

%%//----------------------------------------
%%//         Monitored Trigger PVs
%%//----------------------------------------

int run_tg;
assign run_tg to "{P}{R}ContinuousEvt-Sel";
monitor run_tg;

int run_tg_rbv;
assign run_tg_rbv to "{P}{R}ContinuousEvt-Sts";

int inj_tg;
assign inj_tg to "{P}{R}InjectionEvt-Sel";
monitor inj_tg;

int inj_tg_rbv;
assign inj_tg_rbv to "{P}{R}InjectionEvt-Sts";

int restart_tg;
assign restart_tg to "{P}{R}UpdateEvt-Cmd";
monitor restart_tg;

int repeatinj_tg;
assign repeatinj_tg to "{P}{R}RepeatBucketList-SP";
monitor repeatinj_tg;

%%//----------------------------------------
%%//     Escaped C Code Declaration
%%//----------------------------------------

%%#include <stdlib.h>

%{
    /* Type definitions */

    // Event Mode ENUM
    typedef enum{
  FIX = 0,
  INCR = 1
    } evmode;

    // Event Ctrl ENUM
    typedef enum{
  DISABLE = 0,
  CONTINUOUS = 1,
  INJECTION = 2,
  ONESHOT = 3,
  EXTERNAL = 4
    } evctrl;

    // Event Struct
    typedef struct Event{
  int code;
  int timestamp;
  evmode mode;
  evctrl ctrl;
    } Event;

    /* Variables */

    // Array of pointers to Events
    Event * EventPointerArray[63];
    // Array of Events
    Event EventArray[63];
    // size of both event related arrays
    const int sizeOfArrays = 63;

    /* Functions */
    int str2int(char * str);
    int ch2int(char ch);
    void init_EventPointerArray(int size);
    int bubbleSort(Event * * evArray, int arraySize);
    void swap(Event* *a, Event* *b);
    void updateEventPointerArray(int evNumber, int * code_arr,
         int * time_arr, int * mode_arr, int * control_arr);
    int seqOneWrite(int evnum, SS_ID ssId, int *pseqaddr, int *pseqcode, int *pseqtime,
              VAR_ID seqaddr_id, VAR_ID seqcode_id, VAR_ID seqtime_id, long *seqram1);
                      
    int seqTwoWrite(int repeat, int evnum, int TBL[], int length, SS_ID ssId, int *pseqaddr, int *pseqcode, int *pseqtime,
                VAR_ID seqaddr_id, VAR_ID seqcode_id, VAR_ID seqtime_id, long *seqram2);
    void setAvailableDelay (SS_ID ssId, int* event_timestamps, unsigned int* event_timestampsID, int* EvtDelayVal, unsigned int* EvtDelayNum, int eventNum);
    int checkAvailableDelay (SS_ID ssId, int* event_timestamps, unsigned int* event_timestampsID, int EvtDelayVal, int EvtDelayNum, int eventNum);
}%

%%//----------------------------------------
%%//       State Notation Language
%%//----------------------------------------

ss seq {
  
    state init{ 
        entry
        {
        
             %{/* INITIALIZATION ENTRY    
    
                 -Variable initialization
    
             */}%
             
            %%// Initialize seqram mirrors
            for (i = 0; i < 16384; i++) {
                seqram1[i] = 0;
                seqram2[i] = 0;
            }

            EvtDelayValL = EvtDelayVal;
            EvtDelayNumL = EvtDelayNum;
            EvtTypeL = EvtType;
            EvtModeL = EvtMode;

            %%/* Variable Initialization */
             StateMachineStatus = 0;
             numberOfWrites = 0;
    
             run_tg_rbv = 0;
             pvPut(run_tg_rbv, SYNC);

             inj_tg_rbv = 0;
             pvPut(inj_tg_rbv, SYNC);

            %%// Get macros
             eventNum = str2int(macValueGet("ev_num"));
             printf ("\nEvent count %d\n", eventNum);
             sprintf(device, "%s%s", macValueGet("P"), macValueGet("R"));
        
            %%// Assign events
                for (i = 0; i < eventNum; i++) {
                 sprintf (str, "%s%s%d%s", device, evPrefix, i, evCodeName);
                 pvAssign (event_codes[i], str);
                }

                for (i = 0; i < eventNum; i++) {
                 pvGet (event_codes[i], SYNC);
                 sprintf (str, "%s%s%02d%s", device, evPrefix, event_codes[i], evTimeNameRB);
                 pvAssign (event_timestampsRB[i], str);
                 sprintf (str, "%s%s%02d%s", device, evPrefix, event_codes[i], evTimeNameSP);
                 pvAssign (event_timestampsSP[i], str);
                 pvMonitor (event_timestampsSP[i]);
                 event_timestampsRBID[i] = pvIndex (event_timestampsRB[i]);
                 event_timestampsSPID[i] = pvIndex (event_timestampsSP[i]);
                 setAvailableDelay(ssId, event_timestampsRB, event_timestampsRBID, event_timestampsSP, event_timestampsSPID, eventNum);
                }

                for (i = 0; i < eventNum; i++) {
                 sprintf (str, "%s%s%02d%s", device, evPrefix, event_codes[i], evModeName);
                 pvAssign (event_modes[i], str);
                }

                for (i = 0; i < eventNum; i++) {
                 sprintf (str, "%s%s%02d%s", device, evPrefix, event_codes[i], evCtrlName);
                 pvAssign (event_ctrl[i], str);
                }
                
            %%// Initialize Event Pointer Array
             init_EventPointerArray(eventNum);
    
             %%//printf("Initialization Entry\n");
        }
    
        when(seqs == 0 && network == 1 && (pvConnectCount() == pvAssignCount()))
        {
            %{/* SeqRAM Stopped */}%
    
            printf("Moving to Stopped State\n");
        } state Stopped
    
        when(seqs == 1 && network == 1 && (pvConnectCount() == pvAssignCount()))
        {
            %{/* SeqRAM Running (SeqRAM 1)*/}%
            
            printf("Moving to Running State\n");
            run_tg = 1;
            pvPut(run_tg, SYNC);
            run_tg_rbv = 1;
            pvPut(run_tg_rbv, SYNC);
            
        } state Running
    
        when(seqs == 2 && network == 1 && (pvConnectCount() == pvAssignCount()))
        {
            %{/* SeqRAM Injecting (SeqRAM 2)*/}%
    
            printf("Moving to Injecting State\n");
        } state Injecting
    
        when (delay(10) && (pvConnectCount() != pvAssignCount())) {
    
            %{/* Unable to connect to some PV */}%
    
            printf("Error: Some PVs are still disconnected after 10 s\n");
            printf("Connected: %d Assigned: %d\n", pvConnectCount(), pvAssignCount());
        } state init
    }
    
    state Stopped {
        entry{
    
            %{/* STOPPED ENTRY    
    
            -Status update
            */}%
    
            %%// Status update (stopped)
            StateMachineStatus = 1;
            pvPut(StateMachineStatus, SYNC);
    
            run_tg_rbv = 0;
            pvPut(run_tg_rbv, SYNC);
    
            inj_tg_rbv = 0;
            pvPut(inj_tg_rbv, SYNC);

            %%//printf("Stopped Entry\n");
        }
    
        when(network == 0)
        {
            printf("Network disconnected\n");
        } state init

        when(seqen_rbv != 0){
    
            %{/* Make sure SeqRAM is disabled */}%
            
            seqen = 0;
                 pvPut(seqen, SYNC);
    
        } state Stopped
    
        when(seqen_rbv == 0 && seqcount != 0){
    
            %{/* Reset seqcount and clear number of writes */}%
    
            seqsw = 1;
            pvPut(seqsw, SYNC);
    
            numberOfWrites = 0;
    
            %%// Force seqcountRBV to update
            seqcount_proc = 1;
            pvPut(seqcount_proc, SYNC);
    
        }state Stopped
    
        when(run_tg && (seqcount == 0)){
            %{/* Write to SeqRAM 1 */}%
    
            %%// Status update (preparing to run)
            StateMachineStatus = 4;
            pvPut(StateMachineStatus, SYNC);
    
            run_tg_rbv = 0;
            pvPut(run_tg_rbv, SYNC);
            
            inj_tg_rbv = 0;
            pvPut(inj_tg_rbv, SYNC);

            %%// Update event record arrays
            for(i = 0; i < eventNum; i++){
                
                pvGet(event_codes[i], SYNC);
                pvGet(event_timestampsRB[i], SYNC);
                pvGet(event_modes[i], SYNC);
                pvGet(event_ctrl[i], SYNC);
            }
    
            %%// Update and order EventPointerArray
            updateEventPointerArray(eventNum, event_codes, event_timestampsRB, event_modes, event_ctrl);
    
            numberOfWrites = seqOneWrite(eventNum, ssId, &seqaddr, &seqcode, &seqtime,
                        pvIndex(seqaddr), pvIndex(seqcode), pvIndex(seqtime), seqram1);
    
            %%// Force seqcountRBV to update
            seqcount_proc = 1;
            pvPut(seqcount_proc, SYNC);
    
            printf("Run Triggered\n");
        } state CheckSeq1Write
    
        when(seqs == 1){
    
            %{/* Just go to Running state */}%
    
            %%//printf("Moving to Running State\n");
        } state Running
    
        when(EvtDelayVal != EvtDelayValL || EvtDelayNum != EvtDelayNumL || EvtType != EvtTypeL || EvtMode != EvtModeL){

            EvtDelayValL = EvtDelayVal;
            EvtDelayNumL = EvtDelayNum;
            EvtTypeL = EvtType;
            EvtModeL = EvtMode;
            StatusEvt = 0;
            pvPut (StatusEvt, SYNC);
            setAvailableDelay(ssId, event_timestampsRB, event_timestampsRBID, event_timestampsSP, event_timestampsSPID, eventNum);
    
        } state Stopped

    }
    
    state CheckSeq1Write{
    
        entry{
    
                printf("CheckSeq1Write Entry\n");
    
                printf("EVG:seqen: numberOfWrites= %d, seqcount= %d, seqen_rbv= %d, seqs=%d\n", numberOfWrites, seqcount, seqen_rbv, seqs);
        }
    
        when(network == 0)
        {
            printf("Network disconnected\n");
        } state init

        when(seqcount == numberOfWrites && seqen_rbv == 0){
    
            %{/* Successful Write */}%
    
            %%// Enable SeqRAM
            seqen = 1;
            pvPut(seqen, SYNC);
    
            %%// Switch to SeqRAM 1
            seqsw = 1;
            pvPut(seqsw, SYNC);
    
            printf("Write to SeqRAM 1 succeded\n");
    
        } state CheckSeq1Write
    
        when(seqs == 1){
    
            %%//printf("Going from CheckSeq1Write to Running State\n");
    
            %{/* Just go to Running state */}%
    
            %%//printf("Moving to Running State\n");
        } state Running
    
        when(delay(5.0) && seqs != 1){
    
            %{/* Unsuccessful Write */}%
    
            %%// seqcountRBV will be cleared by seqsw in Stopped Entry
    
            printf("Error: Failed to switch or to write to SeqRAM 1.\n");
    
            %%// Initialize seqram mirrors
            for (i = 0; i < 16384; i++) {
                seqram1[i] = 0;
            }

        } state Stopped
    }
    
    state Running {
    
        entry{
    
            %{/* RUNNING ENTRY    
            
            -Status update
            -Clear numberOfWrites
            
            */}%
            
            %%// Status update (running)
            StateMachineStatus = 2;
            pvPut(StateMachineStatus, SYNC);
            
            run_tg_rbv = 1;
            pvPut(run_tg_rbv, SYNC);
            
            StatusEvt = 1;
            pvPut (StatusEvt, SYNC);

            %%// Clear number of writes
            numberOfWrites = 0;
            
            %%//printf("Running Entry\n");
        }
        
        when(network == 0)
        {
            printf("Network disconnected\n");
        } state init

        when(seqs == 0){
    
            %{/* Just go to Stopped state */}%
    
            %%//printf("Moving to Stopped State\n");
        } state Stopped
    
        when(run_tg == 0){
    
            %{/* Stop SeqRAM (disable SeqRAM) */}%
    
            %%// Disable SeqRAM
            seqen = 0;
            pvPut(seqen, SYNC);
    
            printf("Stop Triggered\n");
        } state Running
    
        when(restart_tg){
    
            %{/* Just go to Restarting state */}%
    
            %%// Reset trigger
            restart_tg = 0;
            pvPut(restart_tg, SYNC);
    
            printf("Restart Triggered\n");
        } state Restarting
    
        when(seqs == 2){
    
            %{/* Just go to Injecting state */}%
    
                    %%//printf("Moving to Injecting State\n");
        } state Injecting
    
        when(inj_tg && tbl_length <= 0){
    
            inj_tg = 0;
            pvPut(inj_tg, SYNC);
            printf("Injection table is empty\n");

        } state Running
    
        when(inj_tg){
    
            %{/* 
                        -Update Bucket list
                        -Update Bucket list length
                        -Write to seqRAM 2
            */}%
    
            %%// Status update (preparing to inject)
            StateMachineStatus = 5;
            pvPut(StateMachineStatus, SYNC);
    
            run_tg_rbv = 1;
            pvPut(run_tg_rbv, SYNC);

            inj_tg_rbv = 0;
            pvPut(inj_tg_rbv, SYNC);

            %%// Update bucket list
            tbl_rbv_proc = 1;
            pvPut(tbl_rbv_proc, SYNC);
            pvGet(tbl_rbv, SYNC);
    
            %%// Update bucket list length
            pvGet(tbl_length, SYNC);
            
            %%// Write to seqRAM 2
            if(tbl_length > 0){
    
                %%// Update event record arrays
                for(i = 0; i < eventNum; i++){
                    
                    pvGet(event_codes[i], SYNC);
                    pvGet(event_timestampsRB[i], SYNC);
                    pvGet(event_modes[i], SYNC);
                    pvGet(event_ctrl[i], SYNC);
                }    
    
                %%// Update and order EventPointerArray
                updateEventPointerArray(eventNum, event_codes, event_timestampsRB, event_modes, event_ctrl);
    
                numberOfWrites = seqTwoWrite(repeatinj_tg, eventNum, tbl_rbv, tbl_length, ssId, &seqaddr, &seqcode, &seqtime,
                                    pvIndex(seqaddr), pvIndex(seqcode), pvIndex(seqtime), seqram2);
    
                %%// Force seqcountRBV to update
                seqcount_proc = 1;
                pvPut(seqcount_proc, SYNC);
            }
    
                    printf("Injection Triggered\n");
        } state CheckSeq2Write

        when(EvtDelayVal != EvtDelayValL || EvtDelayNum != EvtDelayNumL || EvtType != EvtTypeL || EvtMode != EvtModeL){

            EvtDelayValL = EvtDelayVal;
            EvtDelayNumL = EvtDelayNum;
            EvtTypeL = EvtType;
            EvtModeL = EvtMode;
            StatusEvt = 0;
            pvPut (StatusEvt, SYNC);
            setAvailableDelay(ssId, event_timestampsRB, event_timestampsRBID, event_timestampsSP, event_timestampsSPID, eventNum);
    
        } state Running
    
    }
    
    state CheckSeq2Write{
    
        entry{
    
                printf("CheckSeq2Write Entry\n");
    
                printf("EVG:seqen: numberOfWrites= %d, seqcount= %d, seqen_rbv= %d, seqs=%d\n", numberOfWrites, seqcount, seqen_rbv, seqs);
        }
        
    
        when(network == 0)
        {
            printf("Network disconnected\n");
        } state init

        when(seqcount == numberOfWrites){
    
            %{/* Successful Write */}%
    
            %%// Avoid when condition being entered again
            numberOfWrites = -1;
    
            %%// Switch to SeqRAM 2
            seqsw = 1;
            pvPut(seqsw, SYNC);
    
            printf("Write to SeqRAM 2 succeded\n");
    
        } state CheckSeq2Write
    
        when(seqs == 2){
    
            %{/* Just go to Injecting state */}%
    
            %%//printf("Moving to Injecting State\n");
        } state Injecting
    
        when(delay(5.0) && seqs != 2){
    
            %{/* Unsuccessful Write */}%
    
            %%// seqcountRBV will not be cleared
            %%// System will keep failing if not restarted
    
            printf("Error: Failed to switch or to write to SeqRAM 2.\n");
    
            %%// Initialize seqram mirrors
            for (i = 0; i < 16384; i++) {
                seqram2[i] = 0;
            }

        } state Running
    }
    
    state Injecting {
        entry{
    
            %{/* INJECTING ENTRY    
    
            -Status update
            -Seq switch reset
    
            */}%
    
            %%// Status update (injecting)
            StateMachineStatus = 3;
            pvPut(StateMachineStatus, SYNC);
    
            run_tg_rbv = 1;
            pvPut(run_tg_rbv, SYNC);

            inj_tg_rbv = 1;
            pvPut(inj_tg_rbv, SYNC);

            StatusEvt = 1;
            pvPut (StatusEvt, SYNC);

            %%// Seq switch reset (switching condition is only satisfied once)
            seqsw = 0;
    
            %%//printf("Injecting Entry\n");
        }
    
        when(network == 0)
        {
            printf("Network disconnected\n");
        } state init

        when(restart_tg){
    
            %{/* Just go to Restarting state */}%
    
            %%// Reset trigger
            restart_tg = 0;
            pvPut(restart_tg, SYNC);
    
            printf("Restart Triggered\n");
        } state Restarting
    
        when(seqs == 1){
    
            %{/* Just go to Running state */}%
    
                 %%//printf("Moving to Running State\n");
            inj_tg = 0;
            pvPut(inj_tg, SYNC);

            inj_tg_rbv = 0;
            pvPut(inj_tg_rbv, SYNC);

        } state Running
    
        when(inj_tg == 0 && seqsw == 0){
    
            %{/* Return to SeqRAM 1 */}%
    
            %%// Switch seqRAM
            if(seqs == 2){
                 seqsw = 1;
                 pvPut(seqsw, SYNC);
            }
    
                 printf("Stop Inj Triggered\n");
        } state Injecting
    
        when(seqs == 0){
    
            %{/* Just go to Stopped state */}%
    
            %%//printf("Moving to Stopped State\n");
        } state Stopped
    
        when(run_tg == 0){
    
            %{/* Stop SequenceRAM (disable SeqRAM) */}%
    
            %%// Disable SeqRAM
            seqen = 0;
            pvPut(seqen, SYNC);
    
                 printf("Stop Triggered\n");
        } state Injecting

        when(EvtDelayVal != EvtDelayValL || EvtDelayNum != EvtDelayNumL || EvtType != EvtTypeL || EvtMode != EvtModeL){

            EvtDelayValL = EvtDelayVal;
            EvtDelayNumL = EvtDelayNum;
            EvtTypeL = EvtType;
            EvtModeL = EvtMode;
            StatusEvt = 0;
            pvPut (StatusEvt, SYNC);
            setAvailableDelay(ssId, event_timestampsRB, event_timestampsRBID, event_timestampsSP, event_timestampsSPID, eventNum);
    
        } state Injecting
    
    }
    
    state Restarting{
    
        entry{
    
            %{/* RESTARTING ENTRY    
    
            -Status update
            */}%     
    
            %%// Status update (restarting)
            StateMachineStatus = 6;
            pvPut(StateMachineStatus, SYNC);
    
            run_tg_rbv = 0;
            pvPut(run_tg_rbv, SYNC);

            inj_tg_rbv = 0;
            pvPut(inj_tg_rbv, SYNC);

            %%//printf("Restarting Entry\n");
        }
    
        when(network == 0)
        {
            printf("Network disconnected\n");
        } state init

        when(seqen_rbv != 0){
    
            %{/* Make sure SeqRAM is disabled */}%
            
            seqen = 0;
                 pvPut(seqen, SYNC);
    
        } state Restarting
    
        when(seqen_rbv == 0 && seqcount != 0){
    
            %{/* Reset seqcount and clear number of writes */}%
    
            seqsw = 1;
            pvPut(seqsw, SYNC);
    
                        numberOfWrites = 0;
    
            %%// Force seqcountRBV to update
            seqcount_proc = 1;
            pvPut(seqcount_proc, SYNC);
    
        }state Restarting
    
        when(seqs == 0 && seqen_rbv == 0 && seqcount == 0){
    
            %{/* Write to SeqRAM 1 */}%
    
            %%// Update event record arrays
            for(i = 0; i < eventNum; i++){
    
                pvGet(event_codes[i], SYNC);
                pvGet(event_timestampsRB[i], SYNC);
                pvGet(event_modes[i], SYNC);
                pvGet(event_ctrl[i], SYNC);
            }
    
            %%// Update and order EventPointerArray
            updateEventPointerArray(eventNum, event_codes, event_timestampsRB, event_modes, event_ctrl);
    
            numberOfWrites = seqOneWrite(eventNum, ssId, &seqaddr, &seqcode, &seqtime,
                        pvIndex(seqaddr), pvIndex(seqcode), pvIndex(seqtime), seqram1);
    
            %%// Force seqcountRBV to update
            seqcount_proc = 1;
            pvPut(seqcount_proc, SYNC);
    
        } state CheckSeq1Write
    
        when(run_tg == 0){
    
        } state Restarting
    
        when(inj_tg == 0){
    
        } state Restarting
    
        when(run_tg){
    
        } state Restarting
    
        when(inj_tg){
    
        } state Restarting
    
    }
}

%%//----------------------------------------
%%//     Escaped C Code Definition
%%//----------------------------------------

%{
  /* 
     Name: str2int

     Description: Convert a string to its corresponding integer value.

     Arguments: A string containing the representation of an integer value.

     Return: The int value corresponding to the string representation provided.
  */
  int str2int(char * str){

    int num = 0, i = 0;

    while(str[i] != '\0'){

      int aux = ch2int(str[i]);
      if(aux != -1){
        num *= 10;
        num += aux;
      }
      else{
        num = -1;
        break;      
      }      

      i++;
    }

    return num;
  }

  /* 
     Name: ch2int

     Description: Convert a char to its correponding integer value.

     Arguments: A character to be converted.

     Return: An int value corresponding to the char argument.
  */
  int ch2int(char ch){

    int num = 0;

    if(ch =='0')
      num = 0;
    else if(ch == '1')
      num = 1;
    else if(ch == '2')
      num = 2;
    else if(ch == '3')
      num = 3;
    else if(ch == '4')
      num = 4;
    else if(ch == '5')
      num = 5;
    else if(ch == '6')
      num = 6;
    else if(ch == '7')
      num = 7;
    else if(ch == '8')
      num = 8;
    else if(ch == '9')
      num = 9;
    else
      num = -1;

    return num;  
  }

  /*
     Name: init_EventPointerArray

     Description: Initializes the array of pointers EventPointerArray using an array of Events.
      The addresses of the EventArray elements become the elements of the pointer array.

     Arguments: The number of elements in EventPointerArray (equal to EventArray).
  */
  void init_EventPointerArray(int size){

    int i;

    for(i = 0; i < size; i++){

      EventPointerArray[i] = &EventArray[i];
    }
  }

  /*
     Name: bubbleSort

     Description: Sort an array of pointers to Event in ascending order using the Event->timestamp field.
      The algorithm used is bubble sort. A check is included that stop sorting if array is sorted.
      When equal timestamps are found, the event of higher index has its timestamp increased by 1.

     Arguments: First argument is a pointer to the array to be sorted, second argument is the array size.

     Return: 0-> Fail, 1-> Success.
  */
  int bubbleSort(Event* * evArray, int arraySize){

    int sorted = 0;
    int a, b;

    if(evArray == NULL){

      printf("Can't sort Event Array. Event array is null.\n");
      
      // Fail
      return 0;
    }

    // Index of sorted array
    for (a = 0; a < arraySize - 1; a++){

      sorted = 1;      

      // Scan array backward
      for (b = arraySize - 1; b > a; b--){
        
        // swap unordered neighbors
        if (evArray[b-1]->timestamp > evArray[b]->timestamp){ 

          swap(&evArray[b-1], &evArray[b]);
          sorted = 0;
        }

        // handle equal timestamps
        if(evArray[b-1]->timestamp == evArray[b]->timestamp){

          evArray[b]->timestamp += 1;
          sorted = 0;
        }
      }

      // Check if array had no swaps (is ordered)
      if(sorted)
        break;
    }  

    // Success
    return 1;
  }

  /*
     Name: swap

     Description: Swap two elements containing pointers to Event.

     Arguments: First argument is a pointer to the first pointer element.
          Second argument is a pointer to the second pointer element.
  */
  void swap(Event* *a, Event* *b){

    Event * tmp;
    tmp = *a;
    *a = *b;
    *b = tmp;
  }
  /*
     Name: updateEventPointerArray

     Description: Updates the EventPointerArray with the updated event information obtained with pvGet.
      The array is also ordered in ascending order.

     Arguments: First argument is the number of Events pointed to by EventPointerArray.
          Following arguments are updated code, timestamp, mode, and control arrays.   
  */
  void updateEventPointerArray(int evNumber, int * code_arr,
         int * time_arr, int * mode_arr, int * control_arr){

    int i;

    // Copy Events to array
    for(i = 0; i < evNumber; i++){
      
      EventPointerArray[i]->code = code_arr[i];
      EventPointerArray[i]->timestamp = time_arr[i];
      EventPointerArray[i]->mode = mode_arr[i];
      EventPointerArray[i]->ctrl = control_arr[i];
    }

    // Sort events by timestamp in ascending order
    bubbleSort(EventPointerArray, evNumber);
  }

  /*
     Name: seqOneWrite

     Description: Writes to SequenceRAM 1 the events configured as CONTINUOUS.
      The event information is acquired from EventPointerArray.
      Checks if seqRAM pointer is pointing to the address it was supposed to at the end.
      The seqtime record is responsible for triggering the hardware write when processed.

     Arguments: First argument is the total number of events (CONTINUOUS and INJECTION).
          Second argument is the calling state set.
          Next three arguments are pointers to variables seqaddr, seqcode, and seqtime.
          Following three arguments are the VAR_IDs of the variables seqaddr, seqcode, and seqtime.

     Return: Number of write operations performed.     
  */
  int seqOneWrite(int evnum, SS_ID ssId, int *pseqaddr, int *pseqcode, int *pseqtime,
            VAR_ID seqaddr_id, VAR_ID seqcode_id, VAR_ID seqtime_id, long *seqram1){
                      
    int i, maxdelay = 0, address = 0, count = 0;

    // timestamp offset for code 0x7F from previous timestamp
    int offSetEndCode = 10;

    for(i = 0; i < evnum; i++){

      // jump non-always events
      if(EventPointerArray[i]->ctrl != CONTINUOUS)
        continue;

      // define address, get code and timestamp
      *pseqaddr = address;
      *pseqcode = EventPointerArray[i]->code;
      *pseqtime = maxdelay = EventPointerArray[i]->timestamp;

        // write seqram just if it was changed
        if (((*pseqcode) != (seqram1[address]&0xff)) || ((*pseqtime) != (seqram1[address]>>8))){
            seqram1[address] = ((*pseqtime) << 8) + *pseqcode;
            
            // write event info to seqRAM records
            seq_pvPut(ssId, seqaddr_id, SYNC);
            seq_pvPut(ssId, seqcode_id, SYNC);
      
            // write timestamp (wich also triggers write to seqRAM)
            seq_pvPut(ssId, seqtime_id, SYNC);
            count++;
        }

      ////////////// D E B U G G I N G //////////////////////////////////////////

      printf("Write to SeqRAM 1-> seqaddr= %d, seqcode= 0x%x, seqtime= %d\n", *pseqaddr, *pseqcode, *pseqtime);

      ///////////////////////////////////////////////////////////////////////////

      // point to next address
      address++;
    }

        // Send 0x7F code

    // define address, get code and timestamp
    *pseqaddr = address;
    *pseqcode = 0x7F;
    *pseqtime = maxdelay + offSetEndCode;

    // write seqram just if it was changed
    if (((*pseqcode) != (seqram1[address]&0xff)) || ((*pseqtime) != (seqram1[address]>>8))){
        seqram1[address] = ((*pseqtime) << 8) + *pseqcode;
        
        // write event info to seqRAM records
        seq_pvPut(ssId, seqaddr_id, SYNC);
        seq_pvPut(ssId, seqcode_id, SYNC);
  
        // write timestamp (wich also triggers write to seqRAM)
        seq_pvPut(ssId, seqtime_id, SYNC);
        count++;
    }

    ////////////// D E B U G G I N G //////////////////////////////////////////

    printf("Write to SeqRAM 1-> seqaddr= %d, seqcode= 0x%x, seqtime= %d\n", *pseqaddr, *pseqcode, *pseqtime);
    ///////////////////////////////////////////////////////////////////////////


    // point to next address
    address++;

    // return number of writes to SeqRAM
         return count;
  }

  /*
     Name: seqTwoWrite

     Description: Writes to SequenceRAM 2 the events configured as INJECTION.
      The event information is acquired from EventPointerArray.
      Checks if seqRAM pointer is pointing to the address it was supposed to at the end.
      The seqtime record is responsible for triggering the hardware write when processed.

     Arguments: First argument is total number of events (CONTINUOUS and INJECTION).
          Second argument is the bucket array.
          Third argument is the length of the bucket array.
          Next three arguments are pointers to variables seqaddr, seqcode, and seqtime.
          Following three arguments are the VAR_IDs of the variables seqaddr, seqcode, and seqtime.

     Return: Number of write operations performed.     
  */
  int seqTwoWrite(int repeat, int evnum, int TBL[], int length, SS_ID ssId, int *pseqaddr, int *pseqcode, int *pseqtime,
                VAR_ID seqaddr_id, VAR_ID seqcode_id, VAR_ID seqtime_id, long *seqram2){
                  
    int n, i, j, seqdly, rfdly, maxdelay = 0, address = 0, count = 0;

    // timestamp offset for code 0x7E or 0x70 from previous timestamp
    int offSetEndCode = 10;

    // timestamp for sending the RF delay code to modules
    int RFDlyTimestamp = 10;

    printf("Repeat bucket list %d times, write seqram %d\n", repeat, (repeat>0?repeat:repeat+1));
    // Repeat bucket list
    for (n = 0; n < (repeat>0?repeat:repeat+1); n++){

      // for each bucket
      for(i = 0; i < length; i++){
  
        // Ignore bucket numbers greater than 864 (storage ring number of buckets).
        // Ignore bucket numbers smaller than 1.
        printf("Bucket number: %d Repetition: %d\n", TBL[i], n);
        if(TBL[i] > 864 || TBL[i] < 1){
        
          printf("ERROR: Invalid bucket number provided by bucket list. Bucket number was ignored.\n");      
          continue;
        }
  
        // Send appropriate RF delay for modules
        seqdly = TBL[i] / 4;
        rfdly = TBL[i] % 4;
  
        // Set RF Delay Code (code = 0x40 + rfdly)
  
        *pseqaddr = address;
        *pseqcode = 0x40 + rfdly * 5;
        *pseqtime = RFDlyTimestamp;
  
        // write seqram just if it was changed
        if (((*pseqcode) != (seqram2[address]&0xff)) || ((*pseqtime) != (seqram2[address]>>8))){
            seqram2[address] = ((*pseqtime) << 8) + *pseqcode;
            
            // write event info to seqRAM records
            seq_pvPut(ssId, seqaddr_id, SYNC);
            seq_pvPut(ssId, seqcode_id, SYNC);
      
            // write timestamp (wich also triggers write to seqRAM)
            seq_pvPut(ssId, seqtime_id, SYNC);
            count++;

            ////////////// D E B U G G I N G //////////////////////////////////////////
      
            printf("Write to SeqRAM 2-> seqaddr= %d, seqcode= 0x%x, seqtime= %d\n", *pseqaddr, *pseqcode, *pseqtime);
      
            ///////////////////////////////////////////////////////////////////////////
  
        }
        else {
            ////////////// D E B U G G I N G //////////////////////////////////////////
      
            printf("Stay in SeqRAM 2-> seqaddr= %d, seqcode= 0x%x, seqtime= %d\n", *pseqaddr, *pseqcode, *pseqtime);
      
            ///////////////////////////////////////////////////////////////////////////
        }        
        
        // point to next address
        address++;
  
        // write events
        for(j = 0; j < evnum; j++){
  
          // DISABLE and EXTERNAL are not sent
          if(EventPointerArray[j]->ctrl == DISABLE || EventPointerArray[j]->ctrl == EXTERNAL)
            continue;
  
          // ONESHOT event is sent only for the first bucket
          if(EventPointerArray[j]->ctrl == ONESHOT && i > 0)
            continue;
  
          // INJECTION AND CONTINUOUS
          if(EventPointerArray[j]->mode == INCR){      
  
            // Set timestamp WITH seqdly
            *pseqtime = maxdelay = EventPointerArray[j]->timestamp + seqdly;
          }
          else{
  
            // Set timestamp WITHOUT seqdly
            *pseqtime = maxdelay = EventPointerArray[j]->timestamp;
          }
          
  
              // Write Specified Code 
          // specify address and code (timestamp was specified above)
          *pseqaddr = address;
          *pseqcode = EventPointerArray[j]->code;
  
        // write seqram just if it was changed
        if (((*pseqcode) != (seqram2[address]&0xff)) || ((*pseqtime) != (seqram2[address]>>8))){
            seqram2[address] = ((*pseqtime) << 8) + *pseqcode;
            
            // write event info to seqRAM records
            seq_pvPut(ssId, seqaddr_id, SYNC);
            seq_pvPut(ssId, seqcode_id, SYNC);
      
            // write timestamp (wich also triggers write to seqRAM)
            seq_pvPut(ssId, seqtime_id, SYNC);
            count++;
            ////////////// D E B U G G I N G //////////////////////////////////////////
      
            printf("Write to SeqRAM 2-> seqaddr= %d, seqcode= 0x%x, seqtime= %d\n", *pseqaddr, *pseqcode, *pseqtime);
      
            ///////////////////////////////////////////////////////////////////////////
  
        }
        else {
            ////////////// D E B U G G I N G //////////////////////////////////////////
      
            printf("Stay in SeqRAM 2-> seqaddr= %d, seqcode= 0x%x, seqtime= %d\n", *pseqaddr, *pseqcode, *pseqtime);
      
            ///////////////////////////////////////////////////////////////////////////
        }        

          // point to next address
          address++;
          
        }
  
              // SequenceRAM Wait code 
        if(i < length - 1 || n < (repeat-1)){
  
          *pseqcode = 0x70; // Send 0x70 code
          
          // define address and timestamp
          *pseqaddr = address;
          *pseqtime = maxdelay + offSetEndCode;
    
        // write seqram just if it was changed
        if (((*pseqcode) != (seqram2[address]&0xff)) || ((*pseqtime) != (seqram2[address]>>8))){
            seqram2[address] = ((*pseqtime) << 8) + *pseqcode;
            
            // write event info to seqRAM records
            seq_pvPut(ssId, seqaddr_id, SYNC);
            seq_pvPut(ssId, seqcode_id, SYNC);
      
            // write timestamp (wich also triggers write to seqRAM)
            seq_pvPut(ssId, seqtime_id, SYNC);
            count++;
            ////////////// D E B U G G I N G //////////////////////////////////////////
      
            printf("Write to SeqRAM 2-> seqaddr= %d, seqcode= 0x%x, seqtime= %d\n", *pseqaddr, *pseqcode, *pseqtime);
      
            ///////////////////////////////////////////////////////////////////////////
  
        }
        else {
            ////////////// D E B U G G I N G //////////////////////////////////////////
      
            printf("Stay in SeqRAM 2-> seqaddr= %d, seqcode= 0x%x, seqtime= %d\n", *pseqaddr, *pseqcode, *pseqtime);
      
            ///////////////////////////////////////////////////////////////////////////
        }        
  
          // point to next address
          address++;    
        }  
      }
    }

    // Check if bucket list provided valid bucket numbers
    if(address != 0){

      if (repeat > 0) {
        // SequenceRAM code to switch to RAM 1
        *pseqcode = 0x7E; // Send 0x7E code
      }
      else {
        // SequenceRAM code to back to top and wait next injention trigger
        *pseqcode = 0x7F; // Send 0x7F code
      }
      
      // define address and timestamp
      *pseqaddr = address;
      *pseqtime = maxdelay + offSetEndCode;
  
        // write seqram just if it was changed
        if (((*pseqcode) != (seqram2[address]&0xff)) || ((*pseqtime) != (seqram2[address]>>8))){
            seqram2[address] = ((*pseqtime) << 8) + *pseqcode;
            
            // write event info to seqRAM records
            seq_pvPut(ssId, seqaddr_id, SYNC);
            seq_pvPut(ssId, seqcode_id, SYNC);
      
            // write timestamp (wich also triggers write to seqRAM)
            seq_pvPut(ssId, seqtime_id, SYNC);
            count++;
            ////////////// D E B U G G I N G //////////////////////////////////////////
      
            printf("Write to SeqRAM 2-> seqaddr= %d, seqcode= 0x%x, seqtime= %d\n", *pseqaddr, *pseqcode, *pseqtime);
      
            ///////////////////////////////////////////////////////////////////////////
  
        }
        else {
            ////////////// D E B U G G I N G //////////////////////////////////////////
      
            printf("Stay in SeqRAM 2-> seqaddr= %d, seqcode= 0x%x, seqtime= %d\n", *pseqaddr, *pseqcode, *pseqtime);
      
            ///////////////////////////////////////////////////////////////////////////
        }        

      // point to next address
      address++;

      // define address and timestamp
      *pseqaddr = address;
      *pseqtime = maxdelay + offSetEndCode;
  
        // write seqram just if it was changed
        if (((*pseqcode) != (seqram2[address]&0xff)) || ((*pseqtime) != (seqram2[address]>>8))){
            seqram2[address] = ((*pseqtime) << 8) + *pseqcode;
            
            // write event info to seqRAM records
            seq_pvPut(ssId, seqaddr_id, SYNC);
            seq_pvPut(ssId, seqcode_id, SYNC);
      
            // write timestamp (wich also triggers write to seqRAM)
            seq_pvPut(ssId, seqtime_id, SYNC);
            count++;
            ////////////// D E B U G G I N G //////////////////////////////////////////
      
            printf("Write to SeqRAM 2-> seqaddr= %d, seqcode= 0x%x, seqtime= %d\n", *pseqaddr, *pseqcode, *pseqtime);
      
            ///////////////////////////////////////////////////////////////////////////
  
        }
        else {
            ////////////// D E B U G G I N G //////////////////////////////////////////
      
            printf("Stay in SeqRAM 2-> seqaddr= %d, seqcode= 0x%x, seqtime= %d\n", *pseqaddr, *pseqcode, *pseqtime);
      
            ///////////////////////////////////////////////////////////////////////////
        }        

      // point to next address
      address++;
    }

    // return number of writes to SeqRAM
          return count;
  }
  
  /*
     Name: setAvailableDelay

     Description: Check if a delay value is being used by another event.

     Arguments: SS_ID, necessary to access a PV inside a C escape code.
          event_timestamps is the array of event delays.
          event_timestampsID is the array of IDs to access the event delay PVs.
          EvtDelayVal is the required delay to be write to the event.
          EvtDelayNum is the number of the event to write the delay.
          eventNum is the numbers of events, the length of input arrays.

     Return: null.     
  */
  void setAvailableDelay (SS_ID ssId, int* event_timestamps, unsigned int* event_timestampsID, int* EvtDelayVal, unsigned int* event_timestampsSPID, int eventNum) {
    int i = 0;
    int j = 0;

    while(j < eventNum){
      i = 0;
      while(i < eventNum){
          
          seq_pvGet(ssId, event_timestampsID[i], SYNC);
          if (event_timestamps[i] == EvtDelayVal[j] && i != j){ // if delay in use by another event
              EvtDelayVal[j] = EvtDelayVal[j] + 1;
              //printf ("\nEvt %d %d SP %d RB %d mod\n", j, i, EvtDelayVal[j], event_timestamps[i]);
              i = 0;
          }
          else
            i++;
      }
      event_timestamps[j] = EvtDelayVal[j];
      //printf ("\nEvt %d SP %d RB %d new\n", j, EvtDelayVal[j], event_timestamps[j]);
      seq_pvPut(ssId, event_timestampsID[j], SYNC);
      j++;
    }

    i = 0;
    while(i < eventNum){
      seq_pvGet(ssId, event_timestampsSPID[i], SYNC);  
      //printf ("\nEvt %d SP %d RB %d mod\n", i, EvtDelayVal[i], event_timestamps[i]);
      i++;
    }
    
    return;
  }

  /*
     Name: checkAvailableDelay

     Description: Check if a delay value is being used by another event.

     Arguments: SS_ID, necessary to access a PV inside a C escape code.
          event_timestamps is the array of event delays.
          event_timestampsID is the array of IDs to access the event delay PVs.
          EvtDelayVal is the required delay to be write to the event.
          EvtDelayNum is the number of the event to write the delay.
          eventNum is the numbers of events, the length of input arrays.

     Return: 1 if delay available and 0 otherwise.     
  */
  int checkAvailableDelay (SS_ID ssId, int* event_timestamps, unsigned int* event_timestampsID, int EvtDelayVal, int EvtDelayNum, int eventNum) {
    int i = 0;
    int delayAval = 1;
    while(i < eventNum){
        
        seq_pvGet(ssId, event_timestampsID[i], SYNC);
        if (event_timestamps[i] == EvtDelayVal && i != EvtDelayNum){ // if delay in use by another event
            delayAval = 0;
            break;
        }
        i++;
    }
    return delayAval;
  }

}%

  

