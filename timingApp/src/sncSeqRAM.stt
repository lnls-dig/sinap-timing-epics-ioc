program sncSeqRAM

%%// needed for calling seq_pvPut from embedded C code 
foreign ssId;

%%//----------------------------------------
%%// 	        Variables
%%//----------------------------------------

int eventNum;
int expandedEventNum;
char * device;
char * evCodeName = "EVCODE";
char * evTimeName = "EVTIME";
char * evModeName = "EVDLYMODE";
char * evCtrlName = "EVTRANSM";
char str[40];
int i;
int numberOfWrites;

%%//----------------------------------------
%%//	    State Machine Status PVs
%%//----------------------------------------

int StateMachineStatus;
assign StateMachineStatus to "{device}:STATEMACHINE";

%%//----------------------------------------
%%// 	      Monitored PVs
%%//----------------------------------------

int network;
assign network to "{device}:network";
monitor network;

int tbl[2000];
assign tbl to "{device}:ITBL";

int tbl_length;
assign tbl_length to "{device}:ITBL.NORD";

int seqs;
assign seqs to "{device}:seqstat";
monitor seqs;

int seqen_rbv;
assign seqen_rbv to "{device}:seqenRBV";
monitor seqen_rbv;

int seqen;
assign seqen to "{device}:seqen";
int seqsw;
assign seqsw to "{device}:seqram_switch.PROC";
int seqaddr;
assign seqaddr to "{device}:seqaddr";
int seqcode;
assign seqcode to "{device}:seqcode";
int seqtime;
assign seqtime to "{device}:seqtime";

int seqcount;
assign seqcount to "{device}:seqcountRBV";
monitor seqcount;

int proc_seqcount;
assign proc_seqcount to "{device}:seqcountRBV.PROC";

int event_codes[20];
assign event_codes to {};

int event_timestamps[20];
assign event_timestamps to {};

int event_modes[20];
assign event_modes to {};

int event_ctrl[20];
assign event_ctrl to {};

%%//----------------------------------------
%%// 	      Monitored Trigger PVs
%%//----------------------------------------

int stop_pv;
assign stop_pv to "{device}:STOPSEQ";
monitor stop_pv;

int stop_tg;
assign stop_tg to "{device}:STOP_TG.PROC";
monitor stop_tg;
evflag stopFlag;
sync stop_tg stopFlag;

int stopinj_pv;
assign stopinj_pv to "{device}:STOPINJSEQ";
monitor stopinj_pv;

int stopinj_tg;
assign stopinj_tg to "{device}:STOPINJ_TG.PROC";
monitor stopinj_tg;
evflag stopInjFlag;
sync stopinj_tg stopInjFlag;

int run_pv;
assign run_pv to "{device}:RUNSEQ";
monitor run_pv;

int run_tg;
assign run_tg to "{device}:RUN_TG.PROC";
monitor run_tg;
evflag runFlag;
sync run_tg runFlag;

int inj_pv;
assign inj_pv to "{device}:INJSEQ";
monitor inj_pv;

int inj_tg;
assign inj_tg to "{device}:INJ_TG.PROC";
monitor inj_tg;
evflag injFlag;
sync inj_tg injFlag;

int restart_pv;
assign restart_pv to "{device}:RESTSEQ";
monitor restart_pv;

int restart_tg;
assign restart_tg to "{device}:RESTART_TG.PROC";
monitor restart_tg;
evflag restFlag;
sync restart_tg restFlag;

int update_pv;
assign update_pv to "{device}:UPDATEEV";
monitor update_pv;

int update_tg;
assign update_tg to "{device}:UPDATE_TG.PROC";
monitor update_tg;
evflag updateFlag;
sync update_tg updateFlag;

%%//----------------------------------------
%%// 	      Pulse Train PVs
%%//----------------------------------------

int train_enable;
assign train_enable to "{device}:PTEN";
monitor train_enable;

int train_pulse_cnt;
assign train_pulse_cnt to "{device}:PTCNT";
monitor train_pulse_cnt;

float train_duration;
assign train_duration to "{device}:PTLENGTH";
monitor train_duration;

float train_start_time;
assign train_start_time to "{device}:PTSTART";
monitor train_start_time;

int train_pulse_code;
assign train_pulse_code to "{device}:PTCODE";
monitor train_pulse_code;

%%//----------------------------------------
%%// 	    Block Based SeqRAM Write
%%//----------------------------------------

int seqaddr0;
assign seqaddr0 to "{device}:seqaddr0";
int seqcode0;
assign seqcode0 to "{device}:seqcode0";
int seqtime0;
assign seqtime0 to "{device}:seqtime0";

int seqaddr1;
assign seqaddr1 to "{device}:seqaddr1";
int seqcode1;
assign seqcode1 to "{device}:seqcode1";
int seqtime1;
assign seqtime1 to "{device}:seqtime1";

int seqaddr2;
assign seqaddr2 to "{device}:seqaddr2";
int seqcode2;
assign seqcode2 to "{device}:seqcode2";
int seqtime2;
assign seqtime2 to "{device}:seqtime2";

int seqaddr3;
assign seqaddr3 to "{device}:seqaddr3";
int seqcode3;
assign seqcode3 to "{device}:seqcode3";
int seqtime3;
assign seqtime3 to "{device}:seqtime3";

int seqaddr4;
assign seqaddr4 to "{device}:seqaddr4";
int seqcode4;
assign seqcode4 to "{device}:seqcode4";
int seqtime4;
assign seqtime4 to "{device}:seqtime4";

int seqaddr5;
assign seqaddr5 to "{device}:seqaddr5";
int seqcode5;
assign seqcode5 to "{device}:seqcode5";
int seqtime5;
assign seqtime5 to "{device}:seqtime5";

int seqaddr6;
assign seqaddr6 to "{device}:seqaddr6";
int seqcode6;
assign seqcode6 to "{device}:seqcode6";
int seqtime6;
assign seqtime6 to "{device}:seqtime6";

int seqaddr7;
assign seqaddr7 to "{device}:seqaddr7";
int seqcode7;
assign seqcode7 to "{device}:seqcode7";
int seqtime7;
assign seqtime7 to "{device}:seqtime7";

int seqaddr8;
assign seqaddr8 to "{device}:seqaddr8";
int seqcode8;
assign seqcode8 to "{device}:seqcode8";
int seqtime8;
assign seqtime8 to "{device}:seqtime8";

int seqaddr9;
assign seqaddr9 to "{device}:seqaddr9";
int seqcode9;
assign seqcode9 to "{device}:seqcode9";
int seqtime9;
assign seqtime9 to "{device}:seqtime9";

int seqaddrA;
assign seqaddrA to "{device}:seqaddrA";
int seqcodeA;
assign seqcodeA to "{device}:seqcodeA";
int seqtimeA;
assign seqtimeA to "{device}:seqtimeA";

int seqaddrB;
assign seqaddrB to "{device}:seqaddrB";
int seqcodeB;
assign seqcodeB to "{device}:seqcodeB";
int seqtimeB;
assign seqtimeB to "{device}:seqtimeB";

int seqaddrC;
assign seqaddrC to "{device}:seqaddrC";
int seqcodeC;
assign seqcodeC to "{device}:seqcodeC";
int seqtimeC;
assign seqtimeC to "{device}:seqtimeC";

int seqaddrD;
assign seqaddrD to "{device}:seqaddrD";
int seqcodeD;
assign seqcodeD to "{device}:seqcodeD";
int seqtimeD;
assign seqtimeD to "{device}:seqtimeD";

int seqaddrE;
assign seqaddrE to "{device}:seqaddrE";
int seqcodeE;
assign seqcodeE to "{device}:seqcodeE";
int seqtimeE;
assign seqtimeE to "{device}:seqtimeE";

int seqaddrF;
assign seqaddrF to "{device}:seqaddrF";
int seqcodeF;
assign seqcodeF to "{device}:seqcodeF";
int seqtimeF;
assign seqtimeF to "{device}:seqtimeF";

%%//----------------------------------------
%%// 	  Escaped C Code Declaration
%%//----------------------------------------

%%#include <stdlib.h>
%%#include <math.h>

%{
    /* Type definitions */

    // Event Mode ENUM
    typedef enum{
	FIX = 0,
	INCR = 1
    } evmode;

    // Event Ctrl ENUM
    typedef enum{
	ALWAYS = 0,
	INJECTION = 1
    } evctrl;

    // Event Struct
    typedef struct Event{
	int code;
	int timestamp;
	evmode mode;
	evctrl ctrl;
    } Event;

    /* Variables */

    // Array of pointers to Events
    Event * EventPointerArray[20];
    // Array of Events
    Event EventArray[20];
    // size of both event related arrays
    const int sizeOfArrays = 20;
    // Expanded Event Array
    Event ExpandedEventArray[17000];
    // size of expanded event array
    const int sizeOfExpArray = 17000;

    // Block based write PV arrays
    int * blockWritePVs[16][3];
    VAR_ID blockWriteIDs[16][3];
    int numOfBlockEvents = 16;

    /* Functions */
    int str2int(char * str);
    int ch2int(char ch);
    void init_EventPointerArray(int size);
    int bubbleSort(Event * * evArray, int arraySize);
    void swap(Event* *a, Event* *b);
    void updateEventPointerArray(int evNumber, int * code_arr,
				 int * time_arr, int * mode_arr, int * control_arr);
    int seqOneWrite(int evnum, SS_ID ssId, int *pseqaddr, int *pseqcode, int *pseqtime,
			VAR_ID seqaddr_id, VAR_ID seqcode_id, VAR_ID seqtime_id, int * block_pv_array[][3], VAR_ID block_id_array[][3]);
										
    int seqTwoWrite(int evnum, int TBL[], int length, SS_ID ssId, int *pseqaddr, int *pseqcode, int *pseqtime,
			VAR_ID seqaddr_id, VAR_ID seqcode_id, VAR_ID seqtime_id, int * block_pv_array[][3], VAR_ID block_id_array[][3]);

    int expandArray(int trainEnable, float trainStart_ns, float trainDuration_ns, int pulseCnt, int trainCode, int evnum);
    float trainStartCorrection(int trainEnable, float trainStart_ns, float trainDuration_ns, int pulseCnt, int evnum);
    int updateExpandedArray(int trainEnable, float trainStart_ns, float trainDuration_ns, int pulseCnt, int trainCode, int evnum);
}%

%%//----------------------------------------
%%// 	    State Notation Language
%%//----------------------------------------

ss seq {

    state init{ 
	entry
	{
	
	   %{/* INITIALIZATION ENTRY	

	     -Variable initialization

	   */}%
	   
	  %%/* Variable Initialization */
	   StateMachineStatus = 0;
	   numberOfWrites = 0;
	   expandedEventNum = 0;

	  %%// Get macros
	   eventNum = str2int(macValueGet("ev_num"));
	   device = macValueGet("device");
	
	  %%// Assign events
	   for (i = 0; i < eventNum; i++) {
	     sprintf (str, "%s:%s%d", device, evCodeName, i);
	     pvAssign (event_codes[i], str);
	     printf("%s\n", str);
	   }
	   for (i = 0; i < eventNum; i++) {
	     sprintf (str, "%s:%s%d", device, evTimeName, i);
	     pvAssign (event_timestamps[i], str);
	   }
	   for (i = 0; i < eventNum; i++) {
	     sprintf (str, "%s:%s%d", device, evModeName, i);
	     pvAssign (event_modes[i], str);
	   }
	   for (i = 0; i < eventNum; i++) {
	     sprintf (str, "%s:%s%d", device, evCtrlName, i);
	     pvAssign (event_ctrl[i], str);
	   }

	  %%// Initialize Event Pointer Array
	   init_EventPointerArray(eventNum);

	  %%// Update event record arrays
	   for(i = 0; i < eventNum; i++){

		pvGet(event_codes[i], SYNC);
		pvGet(event_timestamps[i], SYNC);
		pvGet(event_modes[i], SYNC);
		pvGet(event_ctrl[i], SYNC);
	   }

	  %%// Update and order EventPointerArray
	   updateEventPointerArray(eventNum, event_codes, event_timestamps, event_modes, event_ctrl);

	  %%// Update expanded array
	   expandedEventNum = updateExpandedArray(train_enable, train_start_time, train_duration,
							train_pulse_cnt, train_pulse_code, eventNum);

	  %%// Initialize array of block-based-write PVs
	   blockWritePVs[0][0] = &seqaddr0;
	   blockWritePVs[0][1] = &seqcode0;
	   blockWritePVs[0][2] = &seqtime0;
	   blockWritePVs[1][0] = &seqaddr1;
	   blockWritePVs[1][1] = &seqcode1;
	   blockWritePVs[1][2] = &seqtime1;
	   blockWritePVs[2][0] = &seqaddr2;
	   blockWritePVs[2][1] = &seqcode2;
	   blockWritePVs[2][2] = &seqtime2;
	   blockWritePVs[3][0] = &seqaddr3;
	   blockWritePVs[3][1] = &seqcode3;
	   blockWritePVs[3][2] = &seqtime3;
	   blockWritePVs[4][0] = &seqaddr4;
	   blockWritePVs[4][1] = &seqcode4;
	   blockWritePVs[4][2] = &seqtime4;
	   blockWritePVs[5][0] = &seqaddr5;
	   blockWritePVs[5][1] = &seqcode5;
	   blockWritePVs[5][2] = &seqtime5;
	   blockWritePVs[6][0] = &seqaddr6;
	   blockWritePVs[6][1] = &seqcode6;
	   blockWritePVs[6][2] = &seqtime6;
	   blockWritePVs[7][0] = &seqaddr7;
	   blockWritePVs[7][1] = &seqcode7;
	   blockWritePVs[7][2] = &seqtime7;
	   blockWritePVs[8][0] = &seqaddr8;
	   blockWritePVs[8][1] = &seqcode8;
	   blockWritePVs[8][2] = &seqtime8;
	   blockWritePVs[9][0] = &seqaddr9;
	   blockWritePVs[9][1] = &seqcode9;
	   blockWritePVs[9][2] = &seqtime9;
	   blockWritePVs[10][0] = &seqaddrA;
	   blockWritePVs[10][1] = &seqcodeA;
	   blockWritePVs[10][2] = &seqtimeA;
	   blockWritePVs[11][0] = &seqaddrB;
	   blockWritePVs[11][1] = &seqcodeB;
	   blockWritePVs[11][2] = &seqtimeB;
	   blockWritePVs[12][0] = &seqaddrC;
	   blockWritePVs[12][1] = &seqcodeC;
	   blockWritePVs[12][2] = &seqtimeC;
	   blockWritePVs[13][0] = &seqaddrD;
	   blockWritePVs[13][1] = &seqcodeD;
	   blockWritePVs[13][2] = &seqtimeD;
	   blockWritePVs[14][0] = &seqaddrE;
	   blockWritePVs[14][1] = &seqcodeE;
	   blockWritePVs[14][2] = &seqtimeE;
	   blockWritePVs[15][0] = &seqaddrF;
	   blockWritePVs[15][1] = &seqcodeF;
	   blockWritePVs[15][2] = &seqtimeF;

	  %%// Initialize array of block-based-write PV IDs
	   blockWriteIDs[0][0] = pvIndex(seqaddr0);
	   blockWriteIDs[0][1] = pvIndex(seqcode0);
	   blockWriteIDs[0][2] = pvIndex(seqtime0);
	   blockWriteIDs[1][0] = pvIndex(seqaddr1);
	   blockWriteIDs[1][1] = pvIndex(seqcode1);
	   blockWriteIDs[1][2] = pvIndex(seqtime1);
	   blockWriteIDs[2][0] = pvIndex(seqaddr2);
	   blockWriteIDs[2][1] = pvIndex(seqcode2);
	   blockWriteIDs[2][2] = pvIndex(seqtime2);
	   blockWriteIDs[3][0] = pvIndex(seqaddr3);
	   blockWriteIDs[3][1] = pvIndex(seqcode3);
	   blockWriteIDs[3][2] = pvIndex(seqtime3);
	   blockWriteIDs[4][0] = pvIndex(seqaddr4);
	   blockWriteIDs[4][1] = pvIndex(seqcode4);
	   blockWriteIDs[4][2] = pvIndex(seqtime4);
	   blockWriteIDs[5][0] = pvIndex(seqaddr5);
	   blockWriteIDs[5][1] = pvIndex(seqcode5);
	   blockWriteIDs[5][2] = pvIndex(seqtime5);
	   blockWriteIDs[6][0] = pvIndex(seqaddr6);
	   blockWriteIDs[6][1] = pvIndex(seqcode6);
	   blockWriteIDs[6][2] = pvIndex(seqtime6);
	   blockWriteIDs[7][0] = pvIndex(seqaddr7);
	   blockWriteIDs[7][1] = pvIndex(seqcode7);
	   blockWriteIDs[7][2] = pvIndex(seqtime7);
	   blockWriteIDs[8][0] = pvIndex(seqaddr8);
	   blockWriteIDs[8][1] = pvIndex(seqcode8);
	   blockWriteIDs[8][2] = pvIndex(seqtime8);
	   blockWriteIDs[9][0] = pvIndex(seqaddr9);
	   blockWriteIDs[9][1] = pvIndex(seqcode9);
	   blockWriteIDs[9][2] = pvIndex(seqtime9);
	   blockWriteIDs[10][0] = pvIndex(seqaddrA);
	   blockWriteIDs[10][1] = pvIndex(seqcodeA);
	   blockWriteIDs[10][2] = pvIndex(seqtimeA);
	   blockWriteIDs[11][0] = pvIndex(seqaddrB);
	   blockWriteIDs[11][1] = pvIndex(seqcodeB);
	   blockWriteIDs[11][2] = pvIndex(seqtimeB);
	   blockWriteIDs[12][0] = pvIndex(seqaddrC);
	   blockWriteIDs[12][1] = pvIndex(seqcodeC);
	   blockWriteIDs[12][2] = pvIndex(seqtimeC);
	   blockWriteIDs[13][0] = pvIndex(seqaddrD);
	   blockWriteIDs[13][1] = pvIndex(seqcodeD);
	   blockWriteIDs[13][2] = pvIndex(seqtimeD);
	   blockWriteIDs[14][0] = pvIndex(seqaddrE);
	   blockWriteIDs[14][1] = pvIndex(seqcodeE);
	   blockWriteIDs[14][2] = pvIndex(seqtimeE);
	   blockWriteIDs[15][0] = pvIndex(seqaddrF);
	   blockWriteIDs[15][1] = pvIndex(seqcodeF);
	   blockWriteIDs[15][2] = pvIndex(seqtimeF);

	   printf("Initialization Entry\n");
	}

	when(seqs == 0 && network == 1)
	{
		%{/* SeqRAM Stopped */}%

		printf("Moving to Stopped State\n");
	} state Stopped

	when(seqs == 1 && network == 1)
	{
		%{/* SeqRAM Running (SeqRAM 1)*/}%

		printf("Moving to Running State\n");
	} state Running

	when(seqs == 2 && network == 1)
	{
		%{/* SeqRAM Injecting (SeqRAM 2)*/}%

		printf("Moving to Injecting State\n");
	} state Injecting
    }

    state Stopped {
	entry{

	   %{/* STOPPED ENTRY	

		-Status update
		-Clear Trigger Flags
		-Update Event Pointer Array
		-Make sure SeqRAM is disabled
		-Reset SequenceRAM Count
		-Clear numberOfWrites
	   */}%

	   %%// Status update (stopped)
	   StateMachineStatus = 1;
	   pvPut(StateMachineStatus, SYNC);

	   %%// Clear Trigger Flags
	   efClear(runFlag);
	   efClear(updateFlag);

	   %%// Update event record arrays
	   for(i = 0; i < eventNum; i++){

		pvGet(event_codes[i], SYNC);
		pvGet(event_timestamps[i], SYNC);
		pvGet(event_modes[i], SYNC);
		pvGet(event_ctrl[i], SYNC);
	   }

	   %%// Update and order EventPointerArray
	   updateEventPointerArray(eventNum, event_codes, event_timestamps, event_modes, event_ctrl);

	   %%// Update expanded array
	   expandedEventNum = updateExpandedArray(train_enable, train_start_time, train_duration,
							train_pulse_cnt, train_pulse_code, eventNum); 

	   printf("Stopped Entry\n");
	}

	when(seqen_rbv != 0){

		%{/* Make sure SeqRAM is disabled */}%
		
		seqen = 0;
	   	pvPut(seqen, SYNC);

	} state Stopped

	when(seqen_rbv == 0 && seqcount != 0){

		%{/* Reset seqcount and clear number of writes */}%

		seqsw = 1;
		pvPut(seqsw, SYNC);

	        numberOfWrites = 0;

	}state Stopped

	when(efTestAndClear(updateFlag) && update_tg){

		%{/* Re-update and re-order EventPointerArray*/}%

		%%// Status update (updating)
	   	StateMachineStatus = 5;
		pvPut(StateMachineStatus, SYNC);

		%%// Update event record arrays
	   	for(i = 0; i < eventNum; i++){

			pvGet(event_codes[i], SYNC);
			pvGet(event_timestamps[i], SYNC);
			pvGet(event_modes[i], SYNC);
			pvGet(event_ctrl[i], SYNC);
	   	}

		%%// Update and order EventPointerArray
	   	updateEventPointerArray(eventNum, event_codes, event_timestamps, event_modes, event_ctrl);

		%%// Update expanded array
		expandedEventNum = updateExpandedArray(train_enable, train_start_time, train_duration,
							train_pulse_cnt, train_pulse_code, eventNum);

		%%// Status update (stopped)
	   	StateMachineStatus = 1;
		pvPut(StateMachineStatus, SYNC);

		printf("Update Finished\n");
	} state Stopped

	when(efTestAndClear(runFlag) && run_tg && (seqcount == 0)){
		
		%{/* Write to SeqRAM 1 */}%

		%%// Status update (preparing to run)
	   	StateMachineStatus = 6;
		pvPut(StateMachineStatus, SYNC);

		numberOfWrites = seqOneWrite(expandedEventNum, ssId, &seqaddr, &seqcode, &seqtime, pvIndex(seqaddr),
							 pvIndex(seqcode), pvIndex(seqtime), blockWritePVs, blockWriteIDs);

		%%// Cause seqcount PV to update
		pvPut(proc_seqcount, SYNC);

		printf("Run Triggered\n");
	} state CheckSeq1Write

	when(seqs == 1){

		%{/* Just go to Running state */}%

		printf("Moving to Running State\n");
	} state Running
    }

    state CheckSeq1Write{

	entry{

	    %{/*
		  -Status Update 
	    */}%

	    printf("CheckSeq1Write Entry\n");

	    printf("Debugging EVG:seqen: numberOfWrites= %d, seqcount= %d, seqen_rbv= %d, seqs=%d\n", numberOfWrites, seqcount, seqen_rbv, seqs);
	}

	when(seqcount == numberOfWrites && seqen_rbv == 0){

		%{/* Successful Write */}%

		%%// Enable SeqRAM
		seqen = 1;
		pvPut(seqen, SYNC);

		%%// Switch to SeqRAM 1
		seqsw = 1;
		pvPut(seqsw, SYNC);

		printf("Write succeded: seqen=%d, seqs=%d\n", seqen, seqs);

	} state CheckSeq1Write

	when(seqs == 1){

		printf("Going from CheckSeq1Write to Running State\n");

		%{/* Just go to Running state */}%

		printf("Moving to Running State\n");
	} state Running

	when(delay(5.0) && seqen_rbv == 0){

		%{/* Unsuccessful Write */}%

		printf("CheckSeq1Write: Unseccessful Write to Seq1, going to Stopped State\n");

		%%// seqcountRBV will be cleared by seqsw in Stopped Entry

		printf("Error: Write to SeqRAM 1 Failed.\n");

	} state Stopped
    }

    state Running {

	entry{

	    %{/* RUNNING ENTRY	

		-Status update
		-Clear Trigger Flags
		-Clear numberOfWrites

	    */}%

	   %%// Status update (running)
	   StateMachineStatus = 2;
	   pvPut(StateMachineStatus, SYNC);

	   %%// Clear Trigger Flags
	   efClear(stopFlag);
	   efClear(injFlag);
	   efClear(restFlag);

	   %%// Clear number of writes
	   numberOfWrites = 0;

	   printf("Running Entry\n");
	}
	
	when(efTestAndClear(stopFlag) && stop_tg){

		%{/* Stop SeqRAM (disable SeqRAM) */}%

		%%// Disable SeqRAM
		seqen = 0;
		pvPut(seqen, SYNC);

	    	printf("Stop Triggered\n");
	} state Running

	when(seqs == 0){

		%{/* Just go to Stopped state */}%

	    	printf("Moving to Stopped State\n");
	} state Stopped

	when(efTestAndClear(injFlag) && inj_tg){

		%{/* 
		      -Update Bucket list
		      -Update Bucket list length
		      -Write to seqRAM 2
		*/}%

		%%// Status update (preparing to inject)
	   	StateMachineStatus = 7;
		pvPut(StateMachineStatus, SYNC);

		%%// Update bucket list
		pvGet(tbl, SYNC);

		%%// Update bucket list length
		pvGet(tbl_length, SYNC);

		%%// Write to seqRAM 2
		if(tbl_length > 0){
			numberOfWrites = seqTwoWrite(expandedEventNum, tbl, tbl_length, ssId, &seqaddr, &seqcode,
				 &seqtime, pvIndex(seqaddr), pvIndex(seqcode), pvIndex(seqtime), blockWritePVs, blockWriteIDs);

			%%// Cause seqcount PV to update
			pvPut(proc_seqcount, SYNC);
		}

	    	printf("Injection Triggered\n");
	} state CheckSeq2Write
	
	when(seqs == 2){

		%{/* Just go to Injecting state */}%

	    	printf("Moving to Injecting State\n");
	} state Injecting

	when(efTestAndClear(restFlag) && restart_tg){

		%{/* Just go to Restarting state */}%

	   	printf("Moving to Restarting State\n");
	} state Restarting
    }

    state CheckSeq2Write{

	entry{

	    %{/*
		  -Status Update 
	    */}%

	    printf("CheckSeq2Write Entry\n");
	}

	when(tbl_length == 0){

		%{/* Just go to Running state */}%

	} state Running

	when(seqcount == numberOfWrites){

		%{/* Successful Write */}%

		%%// Avoid when condition being entered again
		numberOfWrites = -1;

		%%// Switch to SeqRAM 2
		seqsw = 1;
		pvPut(seqsw, SYNC);

	} state CheckSeq2Write

	when(seqs == 2){

		%{/* Just go to Injecting state */}%

		printf("Moving to Injecting State\n");
	} state Injecting

	when(delay(5.0) && seqs != 2){

		%{/* Unsuccessful Write */}%

		%%// seqcountRBV will not be cleared
		%%// System will keep failing if not restarted

		printf("Error: Write to SeqRAM 2 Failed.\n");

	} state Running
    }

    state Injecting {
	entry{

	    %{/* INJECTING ENTRY	

		-Status update
		-Clear Trigger Flags

	    */}%

	   %%// Status update (injecting)
	   StateMachineStatus = 3;
	   pvPut(StateMachineStatus, SYNC);

	   %%// Clear Trigger Flags
	   efClear(stopFlag);

	   printf("Injecting Entry\n");
	}

	when(seqs == 1){

		%{/* Just go to Running state */}%

	   	printf("Moving to Running State\n");
	} state Running

	when(efTestAndClear(stopInjFlag) && stopinj_tg){

		%{/* Return to SeqRAM 1 */}%

		%%// Switch seqRAM
		if(seqs == 2){
		   seqsw = 1;
		   pvPut(seqsw, SYNC);
		}

	   	printf("Stop Inj Triggered\n");
	} state Injecting

	when(efTestAndClear(stopFlag) && stop_tg){

		%{/* Stop SequenceRAM (disable SeqRAM) */}%

		%%// Disable SeqRAM
		seqen = 0;
		pvPut(seqen, SYNC);

	   	printf("Stop Triggered\n");
	} state Injecting

	when(seqs == 0){

		%{/* Just go to Stopped state */}%

		printf("Moving to Stopped State\n");
	} state Stopped
    }

    state Restarting{

	entry{

	    %{/* RESTARTING ENTRY	

		-Status update
		-Stop SequenceRAM
		-Update EventPointerArray
		-Clear numberOfWrites

	    */}%	 

	   %%// Status update (restarting)
	   StateMachineStatus = 4;
	   pvPut(StateMachineStatus, SYNC);

	   %%// Update event record arrays
	   for(i = 0; i < eventNum; i++){

		pvGet(event_codes[i], SYNC);
		pvGet(event_timestamps[i], SYNC);
		pvGet(event_modes[i], SYNC);
		pvGet(event_ctrl[i], SYNC);
	   }

	   %%// Update and order EventPointerArray
	   updateEventPointerArray(eventNum, event_codes, event_timestamps, event_modes, event_ctrl);

	   %%// Update expanded array
	   expandedEventNum = updateExpandedArray(train_enable, train_start_time, train_duration,
							train_pulse_cnt, train_pulse_code, eventNum);

	   printf("Restarting Entry\n");
	}

	when(seqen_rbv != 0){

		%{/* Make sure SeqRAM is disabled */}%
		
		seqen = 0;
	   	pvPut(seqen, SYNC);

	} state Restarting

	when(seqen_rbv == 0 && seqcount != 0){

		%{/* Reset seqcount and clear number of writes */}%

		seqsw = 1;
		pvPut(seqsw, SYNC);

	        numberOfWrites = 0;

	}state Restarting

	when(seqs == 0 && seqen_rbv == 0 && seqcount == 0){

		%{/* Write to SeqRAM 1 */}%

		numberOfWrites = seqOneWrite(expandedEventNum, ssId, &seqaddr, &seqcode, &seqtime, pvIndex(seqaddr),
							pvIndex(seqcode), pvIndex(seqtime), blockWritePVs, blockWriteIDs);

		%%// Cause seqcount PV to update
		pvPut(proc_seqcount, SYNC);

	} state CheckSeq1Write
    }
}

ss reset_tg_pv{
    state checking{
	
	when(stop_pv && delay(1.5)){
	     %{/* Clear stop PV */}%	
		stop_pv = 0;
		pvPut(stop_pv, SYNC);
	} state checking

	when(run_pv && delay(1.5)){
	     %{/* Clear run PV */}%
		run_pv = 0;
		pvPut(run_pv, SYNC);
	} state checking

	when(stopinj_pv && delay(1.5)){
	    %{/* Clear stopinj PV */}%
		stopinj_pv = 0;
		pvPut(stopinj_pv, SYNC);
	} state checking

	when(inj_pv && delay(1.5)){
	    %{/* Clear injection PV */}%
		inj_pv = 0;
		pvPut(inj_pv, SYNC);
	} state checking

	when(restart_pv && delay(1.5)){
	    %{/* Clear restart PV */}%
		restart_pv = 0;
		pvPut(restart_pv, SYNC);
	} state checking

	when(update_pv && delay(1.5)){
	    %{/* Clear update PV */}%
		update_pv = 0;
		pvPut(update_pv, SYNC);
	} state checking	
    }
}

%%//----------------------------------------
%%// 	  Escaped C Code Definition
%%//----------------------------------------

%{
	/* 
	   Name: str2int

	   Description: Convert a string to its corresponding integer value.

	   Arguments: A string containing the representation of an integer value.

	   Return: The int value corresponding to the string representation provided.
	*/
	int str2int(char * str){

		int num = 0, i = 0;

		while(str[i] != '\0'){

			int aux = ch2int(str[i]);
			if(aux != -1){
				num *= 10;
				num += aux;
			}
			else{
				num = -1;
				break;			
			}			

			i++;
		}

		return num;
	}

	/* 
	   Name: ch2int

	   Description: Convert a char to its correponding integer value.

	   Arguments: A character to be converted.

	   Return: An int value corresponding to the char argument.
	*/
	int ch2int(char ch){

		int num = 0;

		if(ch =='0')
			num = 0;
		else if(ch == '1')
			num = 1;
		else if(ch == '2')
			num = 2;
		else if(ch == '3')
			num = 3;
		else if(ch == '4')
			num = 4;
		else if(ch == '5')
			num = 5;
		else if(ch == '6')
			num = 6;
		else if(ch == '7')
			num = 7;
		else if(ch == '8')
			num = 8;
		else if(ch == '9')
			num = 9;
		else
			num = -1;

		return num;	
	}

	/*
	   Name: init_EventPointerArray

	   Description: Initializes the array of pointers EventPointerArray using an array of Events.
			The addresses of the EventArray elements become the elements of the pointer array.

	   Arguments: The number of elements in EventPointerArray (equal to EventArray).
	*/
	void init_EventPointerArray(int size){

		int i;

		for(i = 0; i < size; i++){

			EventPointerArray[i] = &EventArray[i];
		}
	}

	/*
	   Name: bubbleSort

	   Description: Sort an array of pointers to Event in ascending order using the Event->timestamp field.
			The algorithm used is bubble sort. A check is included that stop sorting if array is sorted.
			When equal timestamps are found, the event of higher index has its timestamp increased by 1.

	   Arguments: First argument is a pointer to the array to be sorted, second argument is the array size.

	   Return: 0-> Fail, 1-> Success.
	*/
	int bubbleSort(Event* * evArray, int arraySize){

		int sorted = 0;
		int a, b;

		if(evArray == NULL){

			printf("Can't sort Event Array. Event array is null.\n");
			
			// Fail
			return 0;
		}

		// Index of sorted array
		for (a = 0; a < arraySize - 1; a++){

			sorted = 1;			

			// Scan array backward
			for (b = arraySize - 1; b > a; b--){
				
				// swap unordered neighbors
				if (evArray[b-1]->timestamp > evArray[b]->timestamp){ 

					swap(&evArray[b-1], &evArray[b]);
					sorted = 0;
				}

				// handle equal timestamps
				if(evArray[b-1]->timestamp == evArray[b]->timestamp){

					evArray[b]->timestamp += 1;
					sorted = 0;
				}
			}

			// Check if array had no swaps (is ordered)
			if(sorted)
				break;
		}	

		// Success
		return 1;
	}

	/*
	   Name: swap

	   Description: Swap two elements containing pointers to Event.

	   Arguments: First argument is a pointer to the first pointer element.
		      Second argument is a pointer to the second pointer element.
	*/
	void swap(Event* *a, Event* *b){

		Event * tmp;
		tmp = *a;
		*a = *b;
		*b = tmp;
	}
	/*
	   Name: updateEventPointerArray

	   Description: Updates the EventPointerArray with the updated event information obtained with pvGet.
			The array is also ordered in ascending order.

	   Arguments: First argument is the number of Events pointed to by EventPointerArray.
		      Following arguments are updated code, timestamp, mode, and control arrays.   
	*/
	void updateEventPointerArray(int evNumber, int * code_arr,
				 int * time_arr, int * mode_arr, int * control_arr){

		int i;

		// Copy Events to array
		for(i = 0; i < evNumber; i++){
				
			EventPointerArray[i]->code = code_arr[i];
			EventPointerArray[i]->timestamp = time_arr[i];
			EventPointerArray[i]->mode = mode_arr[i];
			EventPointerArray[i]->ctrl = control_arr[i];
		}

		// Sort events by timestamp in ascending order
		bubbleSort(EventPointerArray, evNumber);
	}

	/*
	   Name: blockWrite

	   Description: Writes to a set of records that trigger a write to 16 lines of the Sequence RAM
			in the same protocol.
			This strategy increases writing speed.

	   Arguments: First argument is the Sequence RAM write starting address.
		      Second argument is an array containing the event data to be written.
		      Third argument is the event data array length.
		      Fourth argument is the calling state set.
		      Fifth argument is the array containing the set of PVs related to block-based-write.
		      Sixth argument is the array containing the set of IDs related to block-based-write PVs.

	   Return: Next Sequence RAM address available.		
	*/
	int blockWrite(int address, Event writeArray[], int array_length, SS_ID ssId,
					 int * block_pv_array[][3], VAR_ID block_id_array[][3]){

		int i;

		// change variables
		for(i = 0; i < array_length; i++){
			*block_pv_array[i][0] = address++;
			*block_pv_array[i][1] = writeArray[i].code;
			*block_pv_array[i][2] = writeArray[i].timestamp;
		}

		// update PVs (last timestamp updated triggers write)
		for(i = 0; i < array_length; i++){
			seq_pvPut(ssId, block_id_array[i][0], SYNC); // address
			seq_pvPut(ssId, block_id_array[i][1], SYNC); // code
			seq_pvPut(ssId, block_id_array[i][2], SYNC); // timestamp
		}

	       // return next available address
		return address;
	}

	/*
	   Name: simpleWrite

	   Description: Writes to a set of records that trigger individual writes to the Sequence RAM
			using one call to the protocol for each line written in the RAM.
			This strategy is used when there are less than 16 lines still to be written.

	   Arguments: First argument is the Sequence RAM write starting address.
		      Second argument is an array containing the event data to be written.
		      Third argument is the event data array length.
		      Fourth argument is the calling state set.
		      Following three arguments are pointers to the related seqRAM PVs.
		      Next three arguments are the respective IDs of the seqRAM PVs.

	   Return: Next Sequence RAM address available.		
	*/
	int simpleWrite(int address, Event writeArray[], int array_length, SS_ID ssId,	int* pseqaddr, int* pseqcode,
						 int* pseqtime, VAR_ID seqaddr_id, VAR_ID seqcode_id, VAR_ID seqtime_id){

		int i;

		for(i = 0; i < array_length; i++){

			// change variables
			*pseqaddr = address++;
			*pseqcode = writeArray[i].code;
			*pseqtime = writeArray[i].timestamp;

			// update PVs (timestamp processing triggers write)
			seq_pvPut(ssId, seqaddr_id, SYNC); // address
			seq_pvPut(ssId, seqcode_id, SYNC); // code
			seq_pvPut(ssId, seqtime_id, SYNC); // timestamp
		}

	       // return next available address
		return address;
	}


	/*
	   Name: seqOneWrite

	   Description: Writes to SequenceRAM 1 the events configured as ALWAYS.
			The event information is acquired from ExpandedEventArray.
			Checks if seqRAM pointer is pointing to the address it was supposed to at the end.
			The seqtime record is responsible for triggering the hardware write when processed.

	   Arguments: First argument is the total number of events after expansion.
		      Second argument is the calling state set.
		      Next three arguments are pointers to variables seqaddr, seqcode and seqtime.
		      Following three arguments are the VAR_IDs of the variables seqaddr, seqcode and seqtime.
		      Last two arguments are the arrays that store the PVs and the respective indexes for block based write.

	   Return: Number of write operations performed.	   
	*/
	int seqOneWrite(int evnum, SS_ID ssId, int *pseqaddr, int *pseqcode, int *pseqtime, VAR_ID seqaddr_id,
				VAR_ID seqcode_id, VAR_ID seqtime_id, int * block_pv_array[][3], VAR_ID block_id_array[][3]){
							
		int i, address = 0;

		// timestamp offset for code 0x7F from previous timestamp
		int offSetEndCode = 10;

		// Array to store event data for fast write (also used for slow procedure)
		const int full_size = 16;
		Event writeArray[full_size];
		int writeArrayIndex = 0;

		// Add 0x7F code as last event
		ExpandedEventArray[evnum].code = 0x7F;
		ExpandedEventArray[evnum].timestamp = ExpandedEventArray[evnum-1].timestamp + offSetEndCode;
		ExpandedEventArray[evnum].ctrl = ALWAYS;
		evnum++;

		for(i = 0; i < evnum; i++){

			// Check if write array is full
			if(writeArrayIndex >= full_size){

				// write block
				address = blockWrite(address, writeArray, full_size, ssId, block_pv_array, block_id_array);

				// clear array
				writeArrayIndex = 0;	
			}

			// Add current event to array
			if(ExpandedEventArray[i].ctrl == ALWAYS){
				writeArray[writeArrayIndex].code = ExpandedEventArray[i].code;
				writeArray[writeArrayIndex].timestamp = ExpandedEventArray[i].timestamp;
				writeArrayIndex++;
			}

			// Check if this is the last event
			if(i >= evnum -1){

				// write to hardware using fast procedure if array is full
				if(writeArrayIndex >= full_size){

					// write block
					address = blockWrite(address, writeArray, full_size, ssId, 
									block_pv_array, block_id_array);	
				}else{
				// write using slow procedure

					// write each single event data separately
					address = simpleWrite(address, writeArray, writeArrayIndex, ssId,
						pseqaddr, pseqcode, pseqtime, seqaddr_id, seqcode_id, seqtime_id);
				}
			}
		}

		// return number of writes to SeqRAM
	     	return address;
	}

	/*
	   Name: seqTwoWrite

	   Description: Writes to SequenceRAM 2 the events configured as INJECTION.
			The event information is acquired from ExpandedEventArray.
			Checks if seqRAM pointer is pointing to the address it was supposed to at the end.
			The seqtime record is responsible for triggering the hardware write when processed.

	   Arguments: First argument is total number of events (ALWAYS and INJECTION).
		      Second argument is the bucket array.
		      Third argument is the length of the bucket array.
		      Next three arguments are pointers to variables seqaddr, seqcode and seqtime.
		      Following three arguments are the VAR_IDs of the variables seqaddr, seqcode and seqtime.
		      Last two arguments are the arrays that store the PVs and the respective indexes for block based write.

	   Return: Number of write operations performed.	   
	*/
	int seqTwoWrite(int evnum, int TBL[], int length, SS_ID ssId, int *pseqaddr, int *pseqcode,
 		int *pseqtime, VAR_ID seqaddr_id, VAR_ID seqcode_id, VAR_ID seqtime_id, int * block_pv_array[][3], VAR_ID block_id_array[][3]){
									
		int i, j, seqdly, rfdly, maxdelay = 0, address = 0;

		// timestamp offset for code 0x7E or 0x70 from previous timestamp
		int offSetEndCode = 10;

		// timestamp for sending the RF delay code to modules
		int RFDlyTimestamp = 10;

		// for each bucket
		for(i = 0; i < length; i++){

			// Send appropriate RF delay for modules
			seqdly = TBL[i] / 4;
			rfdly = TBL[i] % 4;

			// Set RF Delay Code (code = 0x40 + rfdly)

			*pseqaddr = address;
			*pseqcode = 0x40 + rfdly * 5;
			*pseqtime = RFDlyTimestamp;

			// write event info to seqRAM records
			seq_pvPut(ssId, seqaddr_id, SYNC);
			seq_pvPut(ssId, seqcode_id, SYNC);

			// write timestamp (wich also triggers write to seqRAM)
			seq_pvPut(ssId, seqtime_id, SYNC);

			////////////// D E B U G G I N G //////////////////////////////////////////

			printf("Write to SeqRAM 2-> seqaddr= %d, seqcode= %d, seqtime= %d\n", *pseqaddr, *pseqcode, *pseqtime);

			///////////////////////////////////////////////////////////////////////////


			// point to next address
			address++;

			// write events
			for(j = 0; j < evnum; j++){

				// INJECTION
				if(ExpandedEventArray[j].mode == INCR){			

					// Set timestamp WITH seqdly
					*pseqtime = maxdelay = ExpandedEventArray[j].timestamp + seqdly;
				}
				else{

					// Set timestamp WITHOUT seqdly
					*pseqtime = maxdelay = ExpandedEventArray[j].timestamp;
				}
				

			      // Write Specified Code 
				// specify address and code (timestamp was specified above)
				*pseqaddr = address;
				*pseqcode = ExpandedEventArray[j].code;

				// write event info to seqRAM records
				seq_pvPut(ssId, seqaddr_id, SYNC);	
				seq_pvPut(ssId, seqcode_id, SYNC);
	
				// write timestamp (wich also triggers write to seqRAM)
				seq_pvPut(ssId, seqtime_id, SYNC);

				////////////// D E B U G G I N G //////////////////////////////////////////

				printf("Write to SeqRAM 2-> seqaddr= %d, seqcode= %d, seqtime= %d\n", *pseqaddr, *pseqcode, *pseqtime);

				///////////////////////////////////////////////////////////////////////////


				// point to next address
				address++;
				
			}

		        // SequenceRAM Wait code 
			if(i < length - 1){

				*pseqcode = 0x70; // Send 0x70 code
				
				// define address and timestamp
				*pseqaddr = address;
				*pseqtime = maxdelay + offSetEndCode;
	
				// write event info to seqRAM records
				seq_pvPut(ssId, seqaddr_id, SYNC);
				seq_pvPut(ssId, seqcode_id, SYNC);

				// write timestamp (wich also triggers write to seqRAM)
				seq_pvPut(ssId, seqtime_id, SYNC);

				////////////// D E B U G G I N G //////////////////////////////////////////

				printf("Write to SeqRAM 2-> seqaddr= %d, seqcode= %d, seqtime= %d\n", *pseqaddr, *pseqcode, *pseqtime);

				///////////////////////////////////////////////////////////////////////////


				// point to next address
				address++;		
			}	
		}    

		// SequenceRAM Switch RAM code 
		*pseqcode = 0x7E; // Send 0x7E code
		
		// define address and timestamp
		*pseqaddr = address;
		*pseqtime = maxdelay + offSetEndCode;
	
		// write event info to seqRAM records
		seq_pvPut(ssId, seqaddr_id, SYNC);
		seq_pvPut(ssId, seqcode_id, SYNC);

		// write timestamp (wich also triggers write to seqRAM)
		seq_pvPut(ssId, seqtime_id, SYNC);

		////////////// D E B U G G I N G //////////////////////////////////////////

		printf("Write to SeqRAM 2-> seqaddr= %d, seqcode= %d, seqtime= %d\n", *pseqaddr, *pseqcode, *pseqtime);

		///////////////////////////////////////////////////////////////////////////

		// point to next address
		address++;

		// return number of writes to SeqRAM
	        return address;
	}

	/*
	   Name: expandArray

	   Description: Fill the ExpandedEventArray with an expansion of the event pointer array.
			This function is used as means to include a pulse train to the events to be written.

	   Arguments: First argument is the pulse train enable parameter.
		      Second argument is the pulse train start timestamp.
		      Third argument is the pulse train duration.
		      Fourth argument is the pulse train number of pulses.
		      Fifth argument is the pulse train code.
		      Last argument is the number of common events.

	   Return: Total number of events after expansion.	   
	*/
	int expandArray(int trainEnable, float trainStart_ns, float trainDuration_ns, int pulseCnt, int trainCode, int evnum){

		int i, j;

		// Expanded array index
		int expIndex = 0;

		// Convert time units from ns to steps of 8ns
		float trainDuration = trainDuration_ns / 8;
		float trainStart = trainStart_ns / 8;

		// Pulse train variables
		float pulseInterval = trainDuration / pulseCnt;
		float pulseTime = trainStart;
		int pulsesLeft = 0;

		// If pulse train is disabled
		if(trainEnable == 0 || pulseCnt == 0){

			// Copy common events to expanded array
			for(i = 0; i < evnum; i++){

				ExpandedEventArray[expIndex].code = EventPointerArray[i]->code;
				ExpandedEventArray[expIndex].timestamp = EventPointerArray[i]->timestamp;
				ExpandedEventArray[expIndex].mode = EventPointerArray[i]->mode;
				ExpandedEventArray[expIndex].ctrl = EventPointerArray[i]->ctrl;

				expIndex++;
			}

			// return number of events after expansion
			return expIndex;
		}

		
		// Copy events to expanded array
		for(i = 0; i < evnum; i++){

			// Detect beginning of pulse train
			if(trainStart == pulseTime && EventPointerArray[i]->timestamp > trainStart){

				pulsesLeft = pulseCnt;
			}

			// Insert pulses if necessary
			if(pulsesLeft > 0){

				// calculate num of pulses to insert

				int n = 0;

				if(pulseTime < EventPointerArray[i]->timestamp)
					n = floor((EventPointerArray[i]->timestamp - pulseTime) / pulseInterval) + 1;

				if(n > pulsesLeft) n = pulsesLeft;

				// insert pulses
				for(j = 0; j < n; j++){

					ExpandedEventArray[expIndex].code = trainCode;

					ExpandedEventArray[expIndex].timestamp = (int)pulseTime;
					pulseTime += pulseInterval;

					ExpandedEventArray[expIndex].mode = INCR;
					ExpandedEventArray[expIndex].ctrl = ALWAYS;

					// next array index
					expIndex++;
				}

				// update pulses left
				pulsesLeft -= n;
			}

			// Insert common event
			ExpandedEventArray[expIndex].code = EventPointerArray[i]->code;
			ExpandedEventArray[expIndex].timestamp = EventPointerArray[i]->timestamp;
			ExpandedEventArray[expIndex].mode = EventPointerArray[i]->mode;
			ExpandedEventArray[expIndex].ctrl = EventPointerArray[i]->ctrl;

			// next array index
			expIndex++;
		}

		// Detect if the pulse train didn't start
		if(trainStart == pulseTime)
			pulsesLeft = pulseCnt;

		// Insert remaining pulses
		for(i = 0; i < pulsesLeft; i++){

			ExpandedEventArray[expIndex].code = trainCode;
			ExpandedEventArray[expIndex].timestamp = (int)pulseTime;
			pulseTime += pulseInterval;
			ExpandedEventArray[expIndex].mode = INCR;
			ExpandedEventArray[expIndex].ctrl = ALWAYS;

			// next array index
			expIndex++;
		}
		
		// return number of events after expansion
		return expIndex;
	}

	/*
	   Name: trainStartCorrection

	   Description: Redefine the pulse train start timestamp so there are no conflicts with other events.

	   Arguments: First argument is the pulse train enable propertie
		      Second argument is the pulse train start timestamp in ns.
		      Third argument is the pulse train duration.
		      Fourth argument is the number of pulses in the pulse train.
		      Fifth argument is the number of common events.

	   Return: The corrected pulse train start timestamp.	   
	*/
	float trainStartCorrection(int trainEnable, float trainStart_ns, float trainDuration_ns, int pulseCnt, int evnum) {

		if(!trainEnable) return trainStart_ns;

		int i;

		// find interval in ns
		float interval = trainDuration_ns/pulseCnt;

		// convert it to units of 8ns
		interval = interval / 8;

    		for(i = evnum-1; i >= 0; i--){

			int diff = EventPointerArray[i]->timestamp - trainStart_ns/8;
		
			// start of pulse train conflicts
			if((diff <= 0 && diff > -1)

			// OR conflicts after truncation
			    || (interval - fmod(diff, interval) < 1) 	
			
			// OR conflits without truncation
			    || ((floor(diff) == diff && floor(interval) == interval) && fmod(diff, interval) == 0))
				trainStart_ns -= 8;
		}

		// guarantee the timestamp is not negative
		if(trainStart_ns < 0) trainStart_ns = 0;

		// return new starting timestamp
		return trainStart_ns;
	}

	/*
	   Name: updateExpandedArray

	   Description: Update expanded array.

	   Arguments: First argument is the pulse train enable parameter.
		      Second argument is the pulse train start timestamp in ns.
		      Third argument is the pulse train duration in ns.
		      Fourth argument is the pulse train number of pulses.
		      Fifth argument is the pulse train code.
		      Sixth argument is the number of common events.	      

	   Return: The number of events in expanded array.
	*/
	int updateExpandedArray(int trainEnable, float trainStart_ns, float trainDuration_ns, int pulseCnt, int trainCode, int evnum){

		// adjust timestamp for pulse train
		trainStart_ns = trainStartCorrection(trainEnable, trainStart_ns, trainDuration_ns, pulseCnt, evnum);

		// expand array of events and put it into expEvArray
		int newNumEvents = expandArray(trainEnable, trainStart_ns, trainDuration_ns, pulseCnt, trainCode, evnum);

		return newNumEvents;		
	}
}%
