/* C code for program sncSeqRAM, generated by snc from ../sncSeqRAM.stt */
#include <string.h>
#include <stddef.h>
#include <stdio.h>
#include <limits.h>

#include "seq_snc.h"
# line 3 "../sncSeqRAM.stt"
// needed for calling seq_pvPut from embedded C code
# line 6 "../sncSeqRAM.stt"
//----------------------------------------
# line 7 "../sncSeqRAM.stt"
// 	        Variables
# line 8 "../sncSeqRAM.stt"
//----------------------------------------
# line 21 "../sncSeqRAM.stt"
//----------------------------------------
# line 22 "../sncSeqRAM.stt"
//	    State Machine Status PVs
# line 23 "../sncSeqRAM.stt"
//----------------------------------------
# line 28 "../sncSeqRAM.stt"
//----------------------------------------
# line 29 "../sncSeqRAM.stt"
// 	      Monitored PVs
# line 30 "../sncSeqRAM.stt"
//----------------------------------------
# line 77 "../sncSeqRAM.stt"
//----------------------------------------
# line 78 "../sncSeqRAM.stt"
// 	      Monitored Trigger PVs
# line 79 "../sncSeqRAM.stt"
//----------------------------------------
# line 88 "../sncSeqRAM.stt"
static const EF_ID stopFlag = 1;
# line 98 "../sncSeqRAM.stt"
static const EF_ID stopInjFlag = 2;
# line 108 "../sncSeqRAM.stt"
static const EF_ID runFlag = 3;
# line 118 "../sncSeqRAM.stt"
static const EF_ID injFlag = 4;
# line 128 "../sncSeqRAM.stt"
static const EF_ID restFlag = 5;
# line 138 "../sncSeqRAM.stt"
static const EF_ID updateFlag = 6;
# line 141 "../sncSeqRAM.stt"
//----------------------------------------
# line 142 "../sncSeqRAM.stt"
// 	      Pulse Train PVs
# line 143 "../sncSeqRAM.stt"
//----------------------------------------
# line 165 "../sncSeqRAM.stt"
//----------------------------------------
# line 166 "../sncSeqRAM.stt"
// 	  Escaped C Code Declaration
# line 167 "../sncSeqRAM.stt"
//----------------------------------------
# line 169 "../sncSeqRAM.stt"
#include <stdlib.h>
# line 170 "../sncSeqRAM.stt"
#include <math.h>
# line 172 "../sncSeqRAM.stt"

    /* Type definitions */

    // Event Mode ENUM
    typedef enum{
	FIX = 0,
	INCR = 1
    } evmode;

    // Event Ctrl ENUM
    typedef enum{
	ALWAYS = 0,
	INJECTION = 1
    } evctrl;

    // Event Struct
    typedef struct Event{
	int code;
	int timestamp;
	evmode mode;
	evctrl ctrl;
    } Event;

    /* Variables */

    // Array of pointers to Events
    Event * EventPointerArray[20];
    // Array of Events
    Event EventArray[20];
    // size of both event related arrays
    const int sizeOfArrays = 20;
    // Expanded Event Array
    Event ExpandedEventArray[2090];
    // size of expanded event array
    const int sizeOfExpArray = 2090;

    /* Functions */
    int str2int(char * str);
    int ch2int(char ch);
    void init_EventPointerArray(int size);
    int bubbleSort(Event * * evArray, int arraySize);
    void swap(Event* *a, Event* *b);
    void updateEventPointerArray(int evNumber, int * code_arr,
				 int * time_arr, int * mode_arr, int * control_arr);
    int seqOneWrite(int evnum, SS_ID ssId, int *pseqaddr, int *pseqcode, int *pseqtime, int *pseqcount,
					VAR_ID seqaddr_id, VAR_ID seqcode_id, VAR_ID seqtime_id, VAR_ID seqcount_id);
										
    int seqTwoWrite(int evnum, int TBL[], int length, SS_ID ssId, int *pseqaddr, int *pseqcode, int *pseqtime, int *pseqcount,
						VAR_ID seqaddr_id, VAR_ID seqcode_id, VAR_ID seqtime_id, VAR_ID seqcount_id);

    int expandArray(int evnum, int trainEnable, int pulseCnt, int trainDuration, int trainStart, int trainCode);
    int trainStartCorrection(int trainEnable, int trainStart, int trainDuration, int pulseCnt, int evnum);
    int updateExpandedArray(int trainEnable, int trainStart, int trainDuration, int pulseCnt, int trainCode, int evnum);

# line 227 "../sncSeqRAM.stt"
//----------------------------------------
# line 228 "../sncSeqRAM.stt"
// 	    State Notation Language
# line 229 "../sncSeqRAM.stt"
//----------------------------------------

/* Variable declarations */
struct seqg_vars {
# line 10 "../sncSeqRAM.stt"
	int eventNum;
# line 11 "../sncSeqRAM.stt"
	int expandedEventNum;
# line 12 "../sncSeqRAM.stt"
	char *device;
# line 13 "../sncSeqRAM.stt"
	char *evCodeName;
# line 14 "../sncSeqRAM.stt"
	char *evTimeName;
# line 15 "../sncSeqRAM.stt"
	char *evModeName;
# line 16 "../sncSeqRAM.stt"
	char *evCtrlName;
# line 17 "../sncSeqRAM.stt"
	char str[40];
# line 18 "../sncSeqRAM.stt"
	int i;
# line 19 "../sncSeqRAM.stt"
	int numberOfWrites;
# line 25 "../sncSeqRAM.stt"
	int StateMachineStatus;
# line 32 "../sncSeqRAM.stt"
	int network;
# line 36 "../sncSeqRAM.stt"
	int tbl[2000];
# line 39 "../sncSeqRAM.stt"
	int tbl_length;
# line 42 "../sncSeqRAM.stt"
	int seqs;
# line 46 "../sncSeqRAM.stt"
	int seqen_rbv;
# line 50 "../sncSeqRAM.stt"
	int seqen;
# line 52 "../sncSeqRAM.stt"
	int seqsw;
# line 54 "../sncSeqRAM.stt"
	int seqaddr;
# line 56 "../sncSeqRAM.stt"
	int seqcode;
# line 58 "../sncSeqRAM.stt"
	int seqtime;
# line 61 "../sncSeqRAM.stt"
	int seqcount;
# line 65 "../sncSeqRAM.stt"
	int event_codes[20];
# line 68 "../sncSeqRAM.stt"
	int event_timestamps[20];
# line 71 "../sncSeqRAM.stt"
	int event_modes[20];
# line 74 "../sncSeqRAM.stt"
	int event_ctrl[20];
# line 81 "../sncSeqRAM.stt"
	int stop_pv;
# line 85 "../sncSeqRAM.stt"
	int stop_tg;
# line 91 "../sncSeqRAM.stt"
	int stopinj_pv;
# line 95 "../sncSeqRAM.stt"
	int stopinj_tg;
# line 101 "../sncSeqRAM.stt"
	int run_pv;
# line 105 "../sncSeqRAM.stt"
	int run_tg;
# line 111 "../sncSeqRAM.stt"
	int inj_pv;
# line 115 "../sncSeqRAM.stt"
	int inj_tg;
# line 121 "../sncSeqRAM.stt"
	int restart_pv;
# line 125 "../sncSeqRAM.stt"
	int restart_tg;
# line 131 "../sncSeqRAM.stt"
	int update_pv;
# line 135 "../sncSeqRAM.stt"
	int update_tg;
# line 145 "../sncSeqRAM.stt"
	int train_enable;
# line 149 "../sncSeqRAM.stt"
	int train_pulse_cnt;
# line 153 "../sncSeqRAM.stt"
	int train_pulse_size;
# line 157 "../sncSeqRAM.stt"
	int train_start_time;
# line 161 "../sncSeqRAM.stt"
	int train_pulse_code;
};


/* Function declarations */

#define seqg_var (*(struct seqg_vars *const *)seqg_env)

/* Program init func */
static void seqg_init(PROG_ID seqg_env)
{
	{
# line 13 "../sncSeqRAM.stt"
	static char *seqg_initvar_evCodeName = "EVCODE";
	memcpy(&seqg_var->evCodeName, &seqg_initvar_evCodeName, sizeof(seqg_initvar_evCodeName));
	}
	{
# line 14 "../sncSeqRAM.stt"
	static char *seqg_initvar_evTimeName = "EVTIME";
	memcpy(&seqg_var->evTimeName, &seqg_initvar_evTimeName, sizeof(seqg_initvar_evTimeName));
	}
	{
# line 15 "../sncSeqRAM.stt"
	static char *seqg_initvar_evModeName = "EVDLYMODE";
	memcpy(&seqg_var->evModeName, &seqg_initvar_evModeName, sizeof(seqg_initvar_evModeName));
	}
	{
# line 16 "../sncSeqRAM.stt"
	static char *seqg_initvar_evCtrlName = "EVTRANSM";
	memcpy(&seqg_var->evCtrlName, &seqg_initvar_evCtrlName, sizeof(seqg_initvar_evCtrlName));
	}
}

/****** Code for state "init" in state set "seq" ******/

/* Entry function for state "init" in state set "seq" */
static void seqg_entry_seq_0_init(SS_ID seqg_env)
{
	/* C code definitions */
# line 237 "../sncSeqRAM.stt"
	/* INITIALIZATION ENTRY	

	     -Variable initialization

	   */
# line 243 "../sncSeqRAM.stt"
	/* Variable Initialization */
# line 244 "../sncSeqRAM.stt"
	seqg_var->StateMachineStatus = 0;
# line 245 "../sncSeqRAM.stt"
	seqg_var->numberOfWrites = 0;
# line 246 "../sncSeqRAM.stt"
	seqg_var->expandedEventNum = 0;
	// Get macros
# line 249 "../sncSeqRAM.stt"
	seqg_var->eventNum = str2int(seq_macValueGet(seqg_env, "ev_num"));
# line 250 "../sncSeqRAM.stt"
	seqg_var->device = seq_macValueGet(seqg_env, "device");
	// Assign events
# line 253 "../sncSeqRAM.stt"
	for (seqg_var->i = 0; seqg_var->i < seqg_var->eventNum; seqg_var->i++)
	{
# line 254 "../sncSeqRAM.stt"
		sprintf(seqg_var->str, "%s:%s%d", seqg_var->device, seqg_var->evCodeName, seqg_var->i);
# line 255 "../sncSeqRAM.stt"
		seq_pvAssign(seqg_env, 12/*event_codes*/ + (CH_ID)(seqg_var->i), seqg_var->str);
# line 256 "../sncSeqRAM.stt"
		printf("%s\n", seqg_var->str);
	}
# line 258 "../sncSeqRAM.stt"
	for (seqg_var->i = 0; seqg_var->i < seqg_var->eventNum; seqg_var->i++)
	{
# line 259 "../sncSeqRAM.stt"
		sprintf(seqg_var->str, "%s:%s%d", seqg_var->device, seqg_var->evTimeName, seqg_var->i);
# line 260 "../sncSeqRAM.stt"
		seq_pvAssign(seqg_env, 32/*event_timestamps*/ + (CH_ID)(seqg_var->i), seqg_var->str);
	}
# line 262 "../sncSeqRAM.stt"
	for (seqg_var->i = 0; seqg_var->i < seqg_var->eventNum; seqg_var->i++)
	{
# line 263 "../sncSeqRAM.stt"
		sprintf(seqg_var->str, "%s:%s%d", seqg_var->device, seqg_var->evModeName, seqg_var->i);
# line 264 "../sncSeqRAM.stt"
		seq_pvAssign(seqg_env, 52/*event_modes*/ + (CH_ID)(seqg_var->i), seqg_var->str);
	}
# line 266 "../sncSeqRAM.stt"
	for (seqg_var->i = 0; seqg_var->i < seqg_var->eventNum; seqg_var->i++)
	{
# line 267 "../sncSeqRAM.stt"
		sprintf(seqg_var->str, "%s:%s%d", seqg_var->device, seqg_var->evCtrlName, seqg_var->i);
# line 268 "../sncSeqRAM.stt"
		seq_pvAssign(seqg_env, 72/*event_ctrl*/ + (CH_ID)(seqg_var->i), seqg_var->str);
	}
	// Initialize Event Pointer Array
# line 272 "../sncSeqRAM.stt"
	init_EventPointerArray(seqg_var->eventNum);
	// Update event record arrays
# line 275 "../sncSeqRAM.stt"
	for (seqg_var->i = 0; seqg_var->i < seqg_var->eventNum; seqg_var->i++)
	{
# line 277 "../sncSeqRAM.stt"
		seq_pvGetTmo(seqg_env, 12/*event_codes*/ + (CH_ID)(seqg_var->i), SYNC, DEFAULT_TIMEOUT);
# line 278 "../sncSeqRAM.stt"
		seq_pvGetTmo(seqg_env, 32/*event_timestamps*/ + (CH_ID)(seqg_var->i), SYNC, DEFAULT_TIMEOUT);
# line 279 "../sncSeqRAM.stt"
		seq_pvGetTmo(seqg_env, 52/*event_modes*/ + (CH_ID)(seqg_var->i), SYNC, DEFAULT_TIMEOUT);
# line 280 "../sncSeqRAM.stt"
		seq_pvGetTmo(seqg_env, 72/*event_ctrl*/ + (CH_ID)(seqg_var->i), SYNC, DEFAULT_TIMEOUT);
	}
	// Update and order EventPointerArray
# line 284 "../sncSeqRAM.stt"
	updateEventPointerArray(seqg_var->eventNum, seqg_var->event_codes, seqg_var->event_timestamps, seqg_var->event_modes, seqg_var->event_ctrl);
	// Update expanded array
# line 288 "../sncSeqRAM.stt"
	seqg_var->expandedEventNum = updateExpandedArray(seqg_var->train_enable, seqg_var->train_start_time, seqg_var->train_pulse_size, seqg_var->train_pulse_cnt, seqg_var->train_pulse_code, seqg_var->eventNum);
# line 290 "../sncSeqRAM.stt"
	printf("Initialization Entry\n");
}

/* Event function for state "init" in state set "seq" */
static seqBool seqg_event_seq_0_init(SS_ID seqg_env, int *seqg_ptrn, int *seqg_pnst)
{
# line 293 "../sncSeqRAM.stt"
	if (seqg_var->seqs == 0 && seqg_var->network == 1)
	{
		*seqg_pnst = 1;
		*seqg_ptrn = 0;
		return TRUE;
	}
# line 300 "../sncSeqRAM.stt"
	if (seqg_var->seqs == 1 && seqg_var->network == 1)
	{
		*seqg_pnst = 3;
		*seqg_ptrn = 1;
		return TRUE;
	}
# line 307 "../sncSeqRAM.stt"
	if (seqg_var->seqs == 2 && seqg_var->network == 1)
	{
		*seqg_pnst = 5;
		*seqg_ptrn = 2;
		return TRUE;
	}
	return FALSE;
}

/* Action function for state "init" in state set "seq" */
static void seqg_action_seq_0_init(SS_ID seqg_env, int seqg_trn, int *seqg_pnst)
{
	switch(seqg_trn)
	{
	case 0:
		{
			/* C code definitions */
# line 295 "../sncSeqRAM.stt"
			/* SeqRAM Stopped */
# line 297 "../sncSeqRAM.stt"
			printf("Moving to Stopped State\n");
		}
		return;
	case 1:
		{
			/* C code definitions */
# line 302 "../sncSeqRAM.stt"
			/* SeqRAM Running (SeqRAM 1)*/
# line 304 "../sncSeqRAM.stt"
			printf("Moving to Running State\n");
		}
		return;
	case 2:
		{
			/* C code definitions */
# line 309 "../sncSeqRAM.stt"
			/* SeqRAM Injecting (SeqRAM 2)*/
# line 311 "../sncSeqRAM.stt"
			printf("Moving to Injecting State\n");
		}
		return;
	}
}

/****** Code for state "Stopped" in state set "seq" ******/

/* Entry function for state "Stopped" in state set "seq" */
static void seqg_entry_seq_0_Stopped(SS_ID seqg_env)
{
	/* C code definitions */
# line 318 "../sncSeqRAM.stt"
	/* STOPPED ENTRY	

		-Status update
		-Clear Trigger Flags
		-Update Event Pointer Array
		-Make sure SeqRAM is disabled
		-Reset SequenceRAM Count
		-Clear numberOfWrites
	   */
# line 328 "../sncSeqRAM.stt"
	// Status update (stopped)
# line 329 "../sncSeqRAM.stt"
	seqg_var->StateMachineStatus = 1;
# line 330 "../sncSeqRAM.stt"
	seq_pvPutTmo(seqg_env, 0/*StateMachineStatus*/, SYNC, DEFAULT_TIMEOUT);
	// Clear Trigger Flags
# line 333 "../sncSeqRAM.stt"
	seq_efClear(seqg_env, runFlag);
# line 334 "../sncSeqRAM.stt"
	seq_efClear(seqg_env, updateFlag);
	// Update event record arrays
# line 337 "../sncSeqRAM.stt"
	for (seqg_var->i = 0; seqg_var->i < seqg_var->eventNum; seqg_var->i++)
	{
# line 339 "../sncSeqRAM.stt"
		seq_pvGetTmo(seqg_env, 12/*event_codes*/ + (CH_ID)(seqg_var->i), SYNC, DEFAULT_TIMEOUT);
# line 340 "../sncSeqRAM.stt"
		seq_pvGetTmo(seqg_env, 32/*event_timestamps*/ + (CH_ID)(seqg_var->i), SYNC, DEFAULT_TIMEOUT);
# line 341 "../sncSeqRAM.stt"
		seq_pvGetTmo(seqg_env, 52/*event_modes*/ + (CH_ID)(seqg_var->i), SYNC, DEFAULT_TIMEOUT);
# line 342 "../sncSeqRAM.stt"
		seq_pvGetTmo(seqg_env, 72/*event_ctrl*/ + (CH_ID)(seqg_var->i), SYNC, DEFAULT_TIMEOUT);
	}
	// Update and order EventPointerArray
# line 346 "../sncSeqRAM.stt"
	updateEventPointerArray(seqg_var->eventNum, seqg_var->event_codes, seqg_var->event_timestamps, seqg_var->event_modes, seqg_var->event_ctrl);
	// Update expanded array
# line 350 "../sncSeqRAM.stt"
	seqg_var->expandedEventNum = updateExpandedArray(seqg_var->train_enable, seqg_var->train_start_time, seqg_var->train_pulse_size, seqg_var->train_pulse_cnt, seqg_var->train_pulse_code, seqg_var->eventNum);
	// Code below is causing evg enable to be set, when device is disabled while running RAM 2
	// Make sure SeqRAM is disabled
# line 355 "../sncSeqRAM.stt"
	seqg_var->seqen = 0;
# line 356 "../sncSeqRAM.stt"
	seq_pvPutTmo(seqg_env, 6/*seqen*/, SYNC, DEFAULT_TIMEOUT);
	// Clear number of writes
# line 359 "../sncSeqRAM.stt"
	seqg_var->numberOfWrites = 0;
# line 361 "../sncSeqRAM.stt"
	printf("Stopped Entry\n");
}

/* Event function for state "Stopped" in state set "seq" */
static seqBool seqg_event_seq_0_Stopped(SS_ID seqg_env, int *seqg_ptrn, int *seqg_pnst)
{
# line 364 "../sncSeqRAM.stt"
	if (seqg_var->seqen_rbv == 0 && seqg_var->seqcount != 0)
	{
		*seqg_pnst = 1;
		*seqg_ptrn = 0;
		return TRUE;
	}
# line 373 "../sncSeqRAM.stt"
	if (seq_efTestAndClear(seqg_env, updateFlag) && seqg_var->update_tg)
	{
		*seqg_pnst = 1;
		*seqg_ptrn = 1;
		return TRUE;
	}
# line 404 "../sncSeqRAM.stt"
	if (seq_efTestAndClear(seqg_env, runFlag) && seqg_var->run_tg && (seqg_var->seqcount == 0))
	{
		*seqg_pnst = 2;
		*seqg_ptrn = 2;
		return TRUE;
	}
# line 418 "../sncSeqRAM.stt"
	if (seqg_var->seqs == 1)
	{
		*seqg_pnst = 3;
		*seqg_ptrn = 3;
		return TRUE;
	}
	return FALSE;
}

/* Action function for state "Stopped" in state set "seq" */
static void seqg_action_seq_0_Stopped(SS_ID seqg_env, int seqg_trn, int *seqg_pnst)
{
	switch(seqg_trn)
	{
	case 0:
		{
			/* C code definitions */
# line 366 "../sncSeqRAM.stt"
			/* Reset seqcount */
# line 368 "../sncSeqRAM.stt"
			seqg_var->seqsw = 1;
# line 369 "../sncSeqRAM.stt"
			seq_pvPutTmo(seqg_env, 7/*seqsw*/, SYNC, DEFAULT_TIMEOUT);
		}
		return;
	case 1:
		{
			/* C code definitions */
# line 375 "../sncSeqRAM.stt"
			/* Re-update and re-order EventPointerArray*/
# line 377 "../sncSeqRAM.stt"
			// Status update (updating)
# line 378 "../sncSeqRAM.stt"
			seqg_var->StateMachineStatus = 5;
# line 379 "../sncSeqRAM.stt"
			seq_pvPutTmo(seqg_env, 0/*StateMachineStatus*/, SYNC, DEFAULT_TIMEOUT);
			// Update event record arrays
# line 382 "../sncSeqRAM.stt"
			for (seqg_var->i = 0; seqg_var->i < seqg_var->eventNum; seqg_var->i++)
			{
# line 384 "../sncSeqRAM.stt"
				seq_pvGetTmo(seqg_env, 12/*event_codes*/ + (CH_ID)(seqg_var->i), SYNC, DEFAULT_TIMEOUT);
# line 385 "../sncSeqRAM.stt"
				seq_pvGetTmo(seqg_env, 32/*event_timestamps*/ + (CH_ID)(seqg_var->i), SYNC, DEFAULT_TIMEOUT);
# line 386 "../sncSeqRAM.stt"
				seq_pvGetTmo(seqg_env, 52/*event_modes*/ + (CH_ID)(seqg_var->i), SYNC, DEFAULT_TIMEOUT);
# line 387 "../sncSeqRAM.stt"
				seq_pvGetTmo(seqg_env, 72/*event_ctrl*/ + (CH_ID)(seqg_var->i), SYNC, DEFAULT_TIMEOUT);
			}
			// Update and order EventPointerArray
# line 391 "../sncSeqRAM.stt"
			updateEventPointerArray(seqg_var->eventNum, seqg_var->event_codes, seqg_var->event_timestamps, seqg_var->event_modes, seqg_var->event_ctrl);
			// Update expanded array
# line 395 "../sncSeqRAM.stt"
			seqg_var->expandedEventNum = updateExpandedArray(seqg_var->train_enable, seqg_var->train_start_time, seqg_var->train_pulse_size, seqg_var->train_pulse_cnt, seqg_var->train_pulse_code, seqg_var->eventNum);
			// Status update (stopped)
# line 398 "../sncSeqRAM.stt"
			seqg_var->StateMachineStatus = 1;
# line 399 "../sncSeqRAM.stt"
			seq_pvPutTmo(seqg_env, 0/*StateMachineStatus*/, SYNC, DEFAULT_TIMEOUT);
# line 401 "../sncSeqRAM.stt"
			printf("Update Finished\n");
		}
		return;
	case 2:
		{
			/* C code definitions */
# line 406 "../sncSeqRAM.stt"
			/* Write to SeqRAM 1 */
# line 408 "../sncSeqRAM.stt"
			// Status update (preparing to run)
# line 409 "../sncSeqRAM.stt"
			seqg_var->StateMachineStatus = 6;
# line 410 "../sncSeqRAM.stt"
			seq_pvPutTmo(seqg_env, 0/*StateMachineStatus*/, SYNC, DEFAULT_TIMEOUT);
# line 413 "../sncSeqRAM.stt"
			seqg_var->numberOfWrites = seqOneWrite(seqg_var->expandedEventNum, ssId, &seqg_var->seqaddr, &seqg_var->seqcode, &seqg_var->seqtime, &seqg_var->seqcount, seq_pvIndex(seqg_env, 8/*seqaddr*/), seq_pvIndex(seqg_env, 9/*seqcode*/), seq_pvIndex(seqg_env, 10/*seqtime*/), seq_pvIndex(seqg_env, 11/*seqcount*/));
# line 415 "../sncSeqRAM.stt"
			printf("Run Triggered\n");
		}
		return;
	case 3:
		{
			/* C code definitions */
# line 420 "../sncSeqRAM.stt"
			/* Just go to Running state */
# line 422 "../sncSeqRAM.stt"
			printf("Moving to Running State\n");
		}
		return;
	}
}

/****** Code for state "CheckSeq1Write" in state set "seq" ******/

/* Entry function for state "CheckSeq1Write" in state set "seq" */
static void seqg_entry_seq_0_CheckSeq1Write(SS_ID seqg_env)
{
	/* C code definitions */
# line 430 "../sncSeqRAM.stt"
	/*
		  -Status Update 
	    */
# line 434 "../sncSeqRAM.stt"
	printf("CheckSeq1Write Entry\n");
# line 436 "../sncSeqRAM.stt"
	printf("Debugging EVG:seqen: numberOfWrites= %d, seqcount= %d, seqen_rbv= %d, seqs=%d\n", seqg_var->numberOfWrites, seqg_var->seqcount, seqg_var->seqen_rbv, seqg_var->seqs);
}

/* Event function for state "CheckSeq1Write" in state set "seq" */
static seqBool seqg_event_seq_0_CheckSeq1Write(SS_ID seqg_env, int *seqg_ptrn, int *seqg_pnst)
{
# line 439 "../sncSeqRAM.stt"
	if (seqg_var->seqcount == seqg_var->numberOfWrites && seqg_var->seqen_rbv == 0)
	{
		*seqg_pnst = 2;
		*seqg_ptrn = 0;
		return TRUE;
	}
# line 455 "../sncSeqRAM.stt"
	if (seqg_var->seqs == 1)
	{
		*seqg_pnst = 3;
		*seqg_ptrn = 1;
		return TRUE;
	}
# line 464 "../sncSeqRAM.stt"
	if (seq_delay(seqg_env, 5.0) && seqg_var->seqen_rbv == 0)
	{
		*seqg_pnst = 1;
		*seqg_ptrn = 2;
		return TRUE;
	}
	return FALSE;
}

/* Action function for state "CheckSeq1Write" in state set "seq" */
static void seqg_action_seq_0_CheckSeq1Write(SS_ID seqg_env, int seqg_trn, int *seqg_pnst)
{
	switch(seqg_trn)
	{
	case 0:
		{
			/* C code definitions */
# line 441 "../sncSeqRAM.stt"
			/* Successful Write */
# line 443 "../sncSeqRAM.stt"
			// Enable SeqRAM
# line 444 "../sncSeqRAM.stt"
			seqg_var->seqen = 1;
# line 445 "../sncSeqRAM.stt"
			seq_pvPutTmo(seqg_env, 6/*seqen*/, SYNC, DEFAULT_TIMEOUT);
			// Switch to SeqRAM 1
# line 448 "../sncSeqRAM.stt"
			seqg_var->seqsw = 1;
# line 449 "../sncSeqRAM.stt"
			seq_pvPutTmo(seqg_env, 7/*seqsw*/, SYNC, DEFAULT_TIMEOUT);
# line 451 "../sncSeqRAM.stt"
			printf("Write succeded: seqen=%d, seqs=%d\n", seqg_var->seqen, seqg_var->seqs);
		}
		return;
	case 1:
		{
# line 457 "../sncSeqRAM.stt"
			printf("Going from CheckSeq1Write to Running State\n");
			/* Just go to Running state */
# line 461 "../sncSeqRAM.stt"
			printf("Moving to Running State\n");
		}
		return;
	case 2:
		{
			/* C code definitions */
# line 466 "../sncSeqRAM.stt"
			/* Unsuccessful Write */
# line 468 "../sncSeqRAM.stt"
			printf("CheckSeq1Write: Unseccessful Write to Seq1, going to Stopped State\n");
			// seqcountRBV will be cleared by seqsw in Stopped Entry
# line 472 "../sncSeqRAM.stt"
			printf("Error: Write to SeqRAM 1 Failed.\n");
		}
		return;
	}
}

/****** Code for state "Running" in state set "seq" ******/

/* Entry function for state "Running" in state set "seq" */
static void seqg_entry_seq_0_Running(SS_ID seqg_env)
{
	/* C code definitions */
# line 481 "../sncSeqRAM.stt"
	/* RUNNING ENTRY	

		-Status update
		-Clear Trigger Flags
		-Clear numberOfWrites

	    */
# line 489 "../sncSeqRAM.stt"
	// Status update (running)
# line 490 "../sncSeqRAM.stt"
	seqg_var->StateMachineStatus = 2;
# line 491 "../sncSeqRAM.stt"
	seq_pvPutTmo(seqg_env, 0/*StateMachineStatus*/, SYNC, DEFAULT_TIMEOUT);
	// Clear Trigger Flags
# line 494 "../sncSeqRAM.stt"
	seq_efClear(seqg_env, stopFlag);
# line 495 "../sncSeqRAM.stt"
	seq_efClear(seqg_env, injFlag);
# line 496 "../sncSeqRAM.stt"
	seq_efClear(seqg_env, restFlag);
	// Clear number of writes
# line 499 "../sncSeqRAM.stt"
	seqg_var->numberOfWrites = 0;
# line 501 "../sncSeqRAM.stt"
	printf("Running Entry\n");
}

/* Event function for state "Running" in state set "seq" */
static seqBool seqg_event_seq_0_Running(SS_ID seqg_env, int *seqg_ptrn, int *seqg_pnst)
{
# line 504 "../sncSeqRAM.stt"
	if (seq_efTestAndClear(seqg_env, stopFlag) && seqg_var->stop_tg)
	{
		*seqg_pnst = 3;
		*seqg_ptrn = 0;
		return TRUE;
	}
# line 515 "../sncSeqRAM.stt"
	if (seqg_var->seqs == 0)
	{
		*seqg_pnst = 1;
		*seqg_ptrn = 1;
		return TRUE;
	}
# line 522 "../sncSeqRAM.stt"
	if (seq_efTestAndClear(seqg_env, injFlag) && seqg_var->inj_tg)
	{
		*seqg_pnst = 4;
		*seqg_ptrn = 2;
		return TRUE;
	}
# line 547 "../sncSeqRAM.stt"
	if (seqg_var->seqs == 2)
	{
		*seqg_pnst = 5;
		*seqg_ptrn = 3;
		return TRUE;
	}
# line 554 "../sncSeqRAM.stt"
	if (seq_efTestAndClear(seqg_env, restFlag) && seqg_var->restart_tg)
	{
		*seqg_pnst = 6;
		*seqg_ptrn = 4;
		return TRUE;
	}
	return FALSE;
}

/* Action function for state "Running" in state set "seq" */
static void seqg_action_seq_0_Running(SS_ID seqg_env, int seqg_trn, int *seqg_pnst)
{
	switch(seqg_trn)
	{
	case 0:
		{
			/* C code definitions */
# line 506 "../sncSeqRAM.stt"
			/* Stop SeqRAM (disable SeqRAM) */
# line 508 "../sncSeqRAM.stt"
			// Disable SeqRAM
# line 509 "../sncSeqRAM.stt"
			seqg_var->seqen = 0;
# line 510 "../sncSeqRAM.stt"
			seq_pvPutTmo(seqg_env, 6/*seqen*/, SYNC, DEFAULT_TIMEOUT);
# line 512 "../sncSeqRAM.stt"
			printf("Stop Triggered\n");
		}
		return;
	case 1:
		{
			/* C code definitions */
# line 517 "../sncSeqRAM.stt"
			/* Just go to Stopped state */
# line 519 "../sncSeqRAM.stt"
			printf("Moving to Stopped State\n");
		}
		return;
	case 2:
		{
			/* C code definitions */
# line 524 "../sncSeqRAM.stt"
			/* 
		      -Update Bucket list
		      -Update Bucket list length
		      -Write to seqRAM 2
		*/
# line 530 "../sncSeqRAM.stt"
			// Status update (preparing to inject)
# line 531 "../sncSeqRAM.stt"
			seqg_var->StateMachineStatus = 7;
# line 532 "../sncSeqRAM.stt"
			seq_pvPutTmo(seqg_env, 0/*StateMachineStatus*/, SYNC, DEFAULT_TIMEOUT);
			// Update bucket list
# line 535 "../sncSeqRAM.stt"
			seq_pvGetTmo(seqg_env, 2/*tbl*/, SYNC, DEFAULT_TIMEOUT);
			// Update bucket list length
# line 538 "../sncSeqRAM.stt"
			seq_pvGetTmo(seqg_env, 3/*tbl_length*/, SYNC, DEFAULT_TIMEOUT);
			// Write to seqRAM 2
# line 542 "../sncSeqRAM.stt"
			seqg_var->numberOfWrites = seqTwoWrite(seqg_var->expandedEventNum, seqg_var->tbl, seqg_var->tbl_length, ssId, &seqg_var->seqaddr, &seqg_var->seqcode, &seqg_var->seqtime, &seqg_var->seqcount, seq_pvIndex(seqg_env, 8/*seqaddr*/), seq_pvIndex(seqg_env, 9/*seqcode*/), seq_pvIndex(seqg_env, 10/*seqtime*/), seq_pvIndex(seqg_env, 11/*seqcount*/));
# line 544 "../sncSeqRAM.stt"
			printf("Injection Triggered\n");
		}
		return;
	case 3:
		{
			/* C code definitions */
# line 549 "../sncSeqRAM.stt"
			/* Just go to Injecting state */
# line 551 "../sncSeqRAM.stt"
			printf("Moving to Injecting State\n");
		}
		return;
	case 4:
		{
			/* C code definitions */
# line 556 "../sncSeqRAM.stt"
			/* Just go to Restarting state */
# line 558 "../sncSeqRAM.stt"
			printf("Moving to Restarting State\n");
		}
		return;
	}
}

/****** Code for state "CheckSeq2Write" in state set "seq" ******/

/* Entry function for state "CheckSeq2Write" in state set "seq" */
static void seqg_entry_seq_0_CheckSeq2Write(SS_ID seqg_env)
{
	/* C code definitions */
# line 566 "../sncSeqRAM.stt"
	/*
		  -Status Update 
	    */
# line 570 "../sncSeqRAM.stt"
	printf("CheckSeq2Write Entry\n");
}

/* Event function for state "CheckSeq2Write" in state set "seq" */
static seqBool seqg_event_seq_0_CheckSeq2Write(SS_ID seqg_env, int *seqg_ptrn, int *seqg_pnst)
{
# line 573 "../sncSeqRAM.stt"
	if (seqg_var->seqcount == seqg_var->numberOfWrites)
	{
		*seqg_pnst = 4;
		*seqg_ptrn = 0;
		return TRUE;
	}
# line 586 "../sncSeqRAM.stt"
	if (seqg_var->seqs == 2)
	{
		*seqg_pnst = 5;
		*seqg_ptrn = 1;
		return TRUE;
	}
# line 593 "../sncSeqRAM.stt"
	if (seq_delay(seqg_env, 5.0) && seqg_var->seqs != 2)
	{
		*seqg_pnst = 3;
		*seqg_ptrn = 2;
		return TRUE;
	}
	return FALSE;
}

/* Action function for state "CheckSeq2Write" in state set "seq" */
static void seqg_action_seq_0_CheckSeq2Write(SS_ID seqg_env, int seqg_trn, int *seqg_pnst)
{
	switch(seqg_trn)
	{
	case 0:
		{
			/* C code definitions */
# line 575 "../sncSeqRAM.stt"
			/* Successful Write */
# line 577 "../sncSeqRAM.stt"
			// Avoid when condition being entered again
# line 578 "../sncSeqRAM.stt"
			seqg_var->numberOfWrites = -1;
			// Switch to SeqRAM 2
# line 581 "../sncSeqRAM.stt"
			seqg_var->seqsw = 1;
# line 582 "../sncSeqRAM.stt"
			seq_pvPutTmo(seqg_env, 7/*seqsw*/, SYNC, DEFAULT_TIMEOUT);
		}
		return;
	case 1:
		{
			/* C code definitions */
# line 588 "../sncSeqRAM.stt"
			/* Just go to Injecting state */
# line 590 "../sncSeqRAM.stt"
			printf("Moving to Injecting State\n");
		}
		return;
	case 2:
		{
			/* C code definitions */
# line 595 "../sncSeqRAM.stt"
			/* Unsuccessful Write */
# line 597 "../sncSeqRAM.stt"
			// seqcountRBV will not be cleared
# line 598 "../sncSeqRAM.stt"
			// System will keep failing if not restarted
# line 600 "../sncSeqRAM.stt"
			printf("Error: Write to SeqRAM 2 Failed.\n");
		}
		return;
	}
}

/****** Code for state "Injecting" in state set "seq" ******/

/* Entry function for state "Injecting" in state set "seq" */
static void seqg_entry_seq_0_Injecting(SS_ID seqg_env)
{
	/* C code definitions */
# line 608 "../sncSeqRAM.stt"
	/* INJECTING ENTRY	

		-Status update
		-Clear Trigger Flags

	    */
# line 615 "../sncSeqRAM.stt"
	// Status update (injecting)
# line 616 "../sncSeqRAM.stt"
	seqg_var->StateMachineStatus = 3;
# line 617 "../sncSeqRAM.stt"
	seq_pvPutTmo(seqg_env, 0/*StateMachineStatus*/, SYNC, DEFAULT_TIMEOUT);
	// Clear Trigger Flags
# line 620 "../sncSeqRAM.stt"
	seq_efClear(seqg_env, stopFlag);
# line 622 "../sncSeqRAM.stt"
	printf("Injecting Entry\n");
}

/* Event function for state "Injecting" in state set "seq" */
static seqBool seqg_event_seq_0_Injecting(SS_ID seqg_env, int *seqg_ptrn, int *seqg_pnst)
{
# line 625 "../sncSeqRAM.stt"
	if (seqg_var->seqs == 1)
	{
		*seqg_pnst = 3;
		*seqg_ptrn = 0;
		return TRUE;
	}
# line 632 "../sncSeqRAM.stt"
	if (seq_efTestAndClear(seqg_env, stopInjFlag) && seqg_var->stopinj_tg)
	{
		*seqg_pnst = 5;
		*seqg_ptrn = 1;
		return TRUE;
	}
# line 645 "../sncSeqRAM.stt"
	if (seq_efTestAndClear(seqg_env, stopFlag) && seqg_var->stop_tg)
	{
		*seqg_pnst = 5;
		*seqg_ptrn = 2;
		return TRUE;
	}
# line 656 "../sncSeqRAM.stt"
	if (seqg_var->seqs == 0)
	{
		*seqg_pnst = 1;
		*seqg_ptrn = 3;
		return TRUE;
	}
	return FALSE;
}

/* Action function for state "Injecting" in state set "seq" */
static void seqg_action_seq_0_Injecting(SS_ID seqg_env, int seqg_trn, int *seqg_pnst)
{
	switch(seqg_trn)
	{
	case 0:
		{
			/* C code definitions */
# line 627 "../sncSeqRAM.stt"
			/* Just go to Running state */
# line 629 "../sncSeqRAM.stt"
			printf("Moving to Running State\n");
		}
		return;
	case 1:
		{
			/* C code definitions */
# line 634 "../sncSeqRAM.stt"
			/* Return to SeqRAM 1 */
# line 636 "../sncSeqRAM.stt"
			// Switch seqRAM
# line 637 "../sncSeqRAM.stt"
			if (seqg_var->seqs == 2)
			{
# line 638 "../sncSeqRAM.stt"
				seqg_var->seqsw = 1;
# line 639 "../sncSeqRAM.stt"
				seq_pvPutTmo(seqg_env, 7/*seqsw*/, SYNC, DEFAULT_TIMEOUT);
			}
# line 642 "../sncSeqRAM.stt"
			printf("Stop Inj Triggered\n");
		}
		return;
	case 2:
		{
			/* C code definitions */
# line 647 "../sncSeqRAM.stt"
			/* Stop SequenceRAM (disable SeqRAM) */
# line 649 "../sncSeqRAM.stt"
			// Disable SeqRAM
# line 650 "../sncSeqRAM.stt"
			seqg_var->seqen = 0;
# line 651 "../sncSeqRAM.stt"
			seq_pvPutTmo(seqg_env, 6/*seqen*/, SYNC, DEFAULT_TIMEOUT);
# line 653 "../sncSeqRAM.stt"
			printf("Stop Triggered\n");
		}
		return;
	case 3:
		{
			/* C code definitions */
# line 658 "../sncSeqRAM.stt"
			/* Just go to Stopped state */
# line 660 "../sncSeqRAM.stt"
			printf("Moving to Stopped State\n");
		}
		return;
	}
}

/****** Code for state "Restarting" in state set "seq" ******/

/* Entry function for state "Restarting" in state set "seq" */
static void seqg_entry_seq_0_Restarting(SS_ID seqg_env)
{
	/* C code definitions */
# line 668 "../sncSeqRAM.stt"
	/* RESTARTING ENTRY	

		-Status update
		-Stop SequenceRAM
		-Update EventPointerArray
		-Clear numberOfWrites

	    */
# line 677 "../sncSeqRAM.stt"
	// Status update (restarting)
# line 678 "../sncSeqRAM.stt"
	seqg_var->StateMachineStatus = 4;
# line 679 "../sncSeqRAM.stt"
	seq_pvPutTmo(seqg_env, 0/*StateMachineStatus*/, SYNC, DEFAULT_TIMEOUT);
	// Stop SequenceRAM
# line 682 "../sncSeqRAM.stt"
	seqg_var->seqen = 0;
# line 683 "../sncSeqRAM.stt"
	seq_pvPutTmo(seqg_env, 6/*seqen*/, SYNC, DEFAULT_TIMEOUT);
	// Update event record arrays
# line 686 "../sncSeqRAM.stt"
	for (seqg_var->i = 0; seqg_var->i < seqg_var->eventNum; seqg_var->i++)
	{
# line 688 "../sncSeqRAM.stt"
		seq_pvGetTmo(seqg_env, 12/*event_codes*/ + (CH_ID)(seqg_var->i), SYNC, DEFAULT_TIMEOUT);
# line 689 "../sncSeqRAM.stt"
		seq_pvGetTmo(seqg_env, 32/*event_timestamps*/ + (CH_ID)(seqg_var->i), SYNC, DEFAULT_TIMEOUT);
# line 690 "../sncSeqRAM.stt"
		seq_pvGetTmo(seqg_env, 52/*event_modes*/ + (CH_ID)(seqg_var->i), SYNC, DEFAULT_TIMEOUT);
# line 691 "../sncSeqRAM.stt"
		seq_pvGetTmo(seqg_env, 72/*event_ctrl*/ + (CH_ID)(seqg_var->i), SYNC, DEFAULT_TIMEOUT);
	}
	// Update and order EventPointerArray
# line 695 "../sncSeqRAM.stt"
	updateEventPointerArray(seqg_var->eventNum, seqg_var->event_codes, seqg_var->event_timestamps, seqg_var->event_modes, seqg_var->event_ctrl);
	// Update expanded array
# line 699 "../sncSeqRAM.stt"
	seqg_var->expandedEventNum = updateExpandedArray(seqg_var->train_enable, seqg_var->train_start_time, seqg_var->train_pulse_size, seqg_var->train_pulse_cnt, seqg_var->train_pulse_code, seqg_var->eventNum);
	// Clear number of writes
# line 702 "../sncSeqRAM.stt"
	seqg_var->numberOfWrites = 0;
# line 704 "../sncSeqRAM.stt"
	printf("Restarting Entry\n");
}

/* Event function for state "Restarting" in state set "seq" */
static seqBool seqg_event_seq_0_Restarting(SS_ID seqg_env, int *seqg_ptrn, int *seqg_pnst)
{
# line 707 "../sncSeqRAM.stt"
	if (seqg_var->seqs == 0 && seqg_var->seqen_rbv == 0)
	{
		*seqg_pnst = 2;
		*seqg_ptrn = 0;
		return TRUE;
	}
# line 717 "../sncSeqRAM.stt"
	if (seqg_var->seqs == 1 && seqg_var->seqen != 0)
	{
		*seqg_pnst = 3;
		*seqg_ptrn = 1;
		return TRUE;
	}
	return FALSE;
}

/* Action function for state "Restarting" in state set "seq" */
static void seqg_action_seq_0_Restarting(SS_ID seqg_env, int seqg_trn, int *seqg_pnst)
{
	switch(seqg_trn)
	{
	case 0:
		{
			/* C code definitions */
# line 709 "../sncSeqRAM.stt"
			/* Write to SeqRAM 1 */
# line 712 "../sncSeqRAM.stt"
			seqg_var->numberOfWrites = seqOneWrite(seqg_var->expandedEventNum, ssId, &seqg_var->seqaddr, &seqg_var->seqcode, &seqg_var->seqtime, &seqg_var->seqcount, seq_pvIndex(seqg_env, 8/*seqaddr*/), seq_pvIndex(seqg_env, 9/*seqcode*/), seq_pvIndex(seqg_env, 10/*seqtime*/), seq_pvIndex(seqg_env, 11/*seqcount*/));
		}
		return;
	case 1:
		{
			/* C code definitions */
# line 719 "../sncSeqRAM.stt"
			/* Just go to Running State */
# line 721 "../sncSeqRAM.stt"
			printf("Moving to Running State\n");
		}
		return;
	}
}

/****** Code for state "checking" in state set "reset_tg_pv" ******/

/* Event function for state "checking" in state set "reset_tg_pv" */
static seqBool seqg_event_reset_tg_pv_1_checking(SS_ID seqg_env, int *seqg_ptrn, int *seqg_pnst)
{
# line 729 "../sncSeqRAM.stt"
	if (seqg_var->stop_pv && seq_delay(seqg_env, 1.5))
	{
		*seqg_pnst = 0;
		*seqg_ptrn = 0;
		return TRUE;
	}
# line 735 "../sncSeqRAM.stt"
	if (seqg_var->run_pv && seq_delay(seqg_env, 1.5))
	{
		*seqg_pnst = 0;
		*seqg_ptrn = 1;
		return TRUE;
	}
# line 741 "../sncSeqRAM.stt"
	if (seqg_var->stopinj_pv && seq_delay(seqg_env, 1.5))
	{
		*seqg_pnst = 0;
		*seqg_ptrn = 2;
		return TRUE;
	}
# line 747 "../sncSeqRAM.stt"
	if (seqg_var->inj_pv && seq_delay(seqg_env, 1.5))
	{
		*seqg_pnst = 0;
		*seqg_ptrn = 3;
		return TRUE;
	}
# line 753 "../sncSeqRAM.stt"
	if (seqg_var->restart_pv && seq_delay(seqg_env, 1.5))
	{
		*seqg_pnst = 0;
		*seqg_ptrn = 4;
		return TRUE;
	}
# line 759 "../sncSeqRAM.stt"
	if (seqg_var->update_pv && seq_delay(seqg_env, 1.5))
	{
		*seqg_pnst = 0;
		*seqg_ptrn = 5;
		return TRUE;
	}
	return FALSE;
}

/* Action function for state "checking" in state set "reset_tg_pv" */
static void seqg_action_reset_tg_pv_1_checking(SS_ID seqg_env, int seqg_trn, int *seqg_pnst)
{
	switch(seqg_trn)
	{
	case 0:
		{
			/* C code definitions */
# line 730 "../sncSeqRAM.stt"
			/* Clear stop PV */
# line 731 "../sncSeqRAM.stt"
			seqg_var->stop_pv = 0;
# line 732 "../sncSeqRAM.stt"
			seq_pvPutTmo(seqg_env, 92/*stop_pv*/, SYNC, DEFAULT_TIMEOUT);
		}
		return;
	case 1:
		{
			/* C code definitions */
# line 736 "../sncSeqRAM.stt"
			/* Clear run PV */
# line 737 "../sncSeqRAM.stt"
			seqg_var->run_pv = 0;
# line 738 "../sncSeqRAM.stt"
			seq_pvPutTmo(seqg_env, 96/*run_pv*/, SYNC, DEFAULT_TIMEOUT);
		}
		return;
	case 2:
		{
			/* C code definitions */
# line 742 "../sncSeqRAM.stt"
			/* Clear stopinj PV */
# line 743 "../sncSeqRAM.stt"
			seqg_var->stopinj_pv = 0;
# line 744 "../sncSeqRAM.stt"
			seq_pvPutTmo(seqg_env, 94/*stopinj_pv*/, SYNC, DEFAULT_TIMEOUT);
		}
		return;
	case 3:
		{
			/* C code definitions */
# line 748 "../sncSeqRAM.stt"
			/* Clear injection PV */
# line 749 "../sncSeqRAM.stt"
			seqg_var->inj_pv = 0;
# line 750 "../sncSeqRAM.stt"
			seq_pvPutTmo(seqg_env, 98/*inj_pv*/, SYNC, DEFAULT_TIMEOUT);
		}
		return;
	case 4:
		{
			/* C code definitions */
# line 754 "../sncSeqRAM.stt"
			/* Clear restart PV */
# line 755 "../sncSeqRAM.stt"
			seqg_var->restart_pv = 0;
# line 756 "../sncSeqRAM.stt"
			seq_pvPutTmo(seqg_env, 100/*restart_pv*/, SYNC, DEFAULT_TIMEOUT);
		}
		return;
	case 5:
		{
			/* C code definitions */
# line 760 "../sncSeqRAM.stt"
			/* Clear update PV */
# line 761 "../sncSeqRAM.stt"
			seqg_var->update_pv = 0;
# line 762 "../sncSeqRAM.stt"
			seq_pvPutTmo(seqg_env, 102/*update_pv*/, SYNC, DEFAULT_TIMEOUT);
		}
		return;
	}
}

#undef seqg_var

/************************ Tables ************************/

/* Channel table */
static seqChan seqg_chans[] = {
	/* chName, offset, varName, varType, count, eventNum, efId, monitored, queueSize, queueIndex */
	{"{device}:STATEMACHINE", offsetof(struct seqg_vars, StateMachineStatus), "StateMachineStatus", P_INT, 1, 7, 0, 0, 0, 0},
	{"{device}:network", offsetof(struct seqg_vars, network), "network", P_INT, 1, 8, 0, 1, 0, 0},
	{"{device}:ITBL", offsetof(struct seqg_vars, tbl), "tbl", P_INT, 2000, 9, 0, 0, 0, 0},
	{"{device}:ITBL.NORD", offsetof(struct seqg_vars, tbl_length), "tbl_length", P_INT, 1, 10, 0, 0, 0, 0},
	{"{device}:seqstat", offsetof(struct seqg_vars, seqs), "seqs", P_INT, 1, 11, 0, 1, 0, 0},
	{"{device}:seqenRBV", offsetof(struct seqg_vars, seqen_rbv), "seqen_rbv", P_INT, 1, 12, 0, 1, 0, 0},
	{"{device}:seqen", offsetof(struct seqg_vars, seqen), "seqen", P_INT, 1, 13, 0, 0, 0, 0},
	{"{device}:seqram_switch.PROC", offsetof(struct seqg_vars, seqsw), "seqsw", P_INT, 1, 14, 0, 0, 0, 0},
	{"{device}:seqaddr", offsetof(struct seqg_vars, seqaddr), "seqaddr", P_INT, 1, 15, 0, 0, 0, 0},
	{"{device}:seqcode", offsetof(struct seqg_vars, seqcode), "seqcode", P_INT, 1, 16, 0, 0, 0, 0},
	{"{device}:seqtime", offsetof(struct seqg_vars, seqtime), "seqtime", P_INT, 1, 17, 0, 0, 0, 0},
	{"{device}:seqcountRBV", offsetof(struct seqg_vars, seqcount), "seqcount", P_INT, 1, 18, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, event_codes[0]), "event_codes[0]", P_INT, 1, 19, 0, 0, 0, 0},
	{"", offsetof(struct seqg_vars, event_codes[1]), "event_codes[1]", P_INT, 1, 20, 0, 0, 0, 0},
	{"", offsetof(struct seqg_vars, event_codes[2]), "event_codes[2]", P_INT, 1, 21, 0, 0, 0, 0},
	{"", offsetof(struct seqg_vars, event_codes[3]), "event_codes[3]", P_INT, 1, 22, 0, 0, 0, 0},
	{"", offsetof(struct seqg_vars, event_codes[4]), "event_codes[4]", P_INT, 1, 23, 0, 0, 0, 0},
	{"", offsetof(struct seqg_vars, event_codes[5]), "event_codes[5]", P_INT, 1, 24, 0, 0, 0, 0},
	{"", offsetof(struct seqg_vars, event_codes[6]), "event_codes[6]", P_INT, 1, 25, 0, 0, 0, 0},
	{"", offsetof(struct seqg_vars, event_codes[7]), "event_codes[7]", P_INT, 1, 26, 0, 0, 0, 0},
	{"", offsetof(struct seqg_vars, event_codes[8]), "event_codes[8]", P_INT, 1, 27, 0, 0, 0, 0},
	{"", offsetof(struct seqg_vars, event_codes[9]), "event_codes[9]", P_INT, 1, 28, 0, 0, 0, 0},
	{"", offsetof(struct seqg_vars, event_codes[10]), "event_codes[10]", P_INT, 1, 29, 0, 0, 0, 0},
	{"", offsetof(struct seqg_vars, event_codes[11]), "event_codes[11]", P_INT, 1, 30, 0, 0, 0, 0},
	{"", offsetof(struct seqg_vars, event_codes[12]), "event_codes[12]", P_INT, 1, 31, 0, 0, 0, 0},
	{"", offsetof(struct seqg_vars, event_codes[13]), "event_codes[13]", P_INT, 1, 32, 0, 0, 0, 0},
	{"", offsetof(struct seqg_vars, event_codes[14]), "event_codes[14]", P_INT, 1, 33, 0, 0, 0, 0},
	{"", offsetof(struct seqg_vars, event_codes[15]), "event_codes[15]", P_INT, 1, 34, 0, 0, 0, 0},
	{"", offsetof(struct seqg_vars, event_codes[16]), "event_codes[16]", P_INT, 1, 35, 0, 0, 0, 0},
	{"", offsetof(struct seqg_vars, event_codes[17]), "event_codes[17]", P_INT, 1, 36, 0, 0, 0, 0},
	{"", offsetof(struct seqg_vars, event_codes[18]), "event_codes[18]", P_INT, 1, 37, 0, 0, 0, 0},
	{"", offsetof(struct seqg_vars, event_codes[19]), "event_codes[19]", P_INT, 1, 38, 0, 0, 0, 0},
	{"", offsetof(struct seqg_vars, event_timestamps[0]), "event_timestamps[0]", P_INT, 1, 39, 0, 0, 0, 0},
	{"", offsetof(struct seqg_vars, event_timestamps[1]), "event_timestamps[1]", P_INT, 1, 40, 0, 0, 0, 0},
	{"", offsetof(struct seqg_vars, event_timestamps[2]), "event_timestamps[2]", P_INT, 1, 41, 0, 0, 0, 0},
	{"", offsetof(struct seqg_vars, event_timestamps[3]), "event_timestamps[3]", P_INT, 1, 42, 0, 0, 0, 0},
	{"", offsetof(struct seqg_vars, event_timestamps[4]), "event_timestamps[4]", P_INT, 1, 43, 0, 0, 0, 0},
	{"", offsetof(struct seqg_vars, event_timestamps[5]), "event_timestamps[5]", P_INT, 1, 44, 0, 0, 0, 0},
	{"", offsetof(struct seqg_vars, event_timestamps[6]), "event_timestamps[6]", P_INT, 1, 45, 0, 0, 0, 0},
	{"", offsetof(struct seqg_vars, event_timestamps[7]), "event_timestamps[7]", P_INT, 1, 46, 0, 0, 0, 0},
	{"", offsetof(struct seqg_vars, event_timestamps[8]), "event_timestamps[8]", P_INT, 1, 47, 0, 0, 0, 0},
	{"", offsetof(struct seqg_vars, event_timestamps[9]), "event_timestamps[9]", P_INT, 1, 48, 0, 0, 0, 0},
	{"", offsetof(struct seqg_vars, event_timestamps[10]), "event_timestamps[10]", P_INT, 1, 49, 0, 0, 0, 0},
	{"", offsetof(struct seqg_vars, event_timestamps[11]), "event_timestamps[11]", P_INT, 1, 50, 0, 0, 0, 0},
	{"", offsetof(struct seqg_vars, event_timestamps[12]), "event_timestamps[12]", P_INT, 1, 51, 0, 0, 0, 0},
	{"", offsetof(struct seqg_vars, event_timestamps[13]), "event_timestamps[13]", P_INT, 1, 52, 0, 0, 0, 0},
	{"", offsetof(struct seqg_vars, event_timestamps[14]), "event_timestamps[14]", P_INT, 1, 53, 0, 0, 0, 0},
	{"", offsetof(struct seqg_vars, event_timestamps[15]), "event_timestamps[15]", P_INT, 1, 54, 0, 0, 0, 0},
	{"", offsetof(struct seqg_vars, event_timestamps[16]), "event_timestamps[16]", P_INT, 1, 55, 0, 0, 0, 0},
	{"", offsetof(struct seqg_vars, event_timestamps[17]), "event_timestamps[17]", P_INT, 1, 56, 0, 0, 0, 0},
	{"", offsetof(struct seqg_vars, event_timestamps[18]), "event_timestamps[18]", P_INT, 1, 57, 0, 0, 0, 0},
	{"", offsetof(struct seqg_vars, event_timestamps[19]), "event_timestamps[19]", P_INT, 1, 58, 0, 0, 0, 0},
	{"", offsetof(struct seqg_vars, event_modes[0]), "event_modes[0]", P_INT, 1, 59, 0, 0, 0, 0},
	{"", offsetof(struct seqg_vars, event_modes[1]), "event_modes[1]", P_INT, 1, 60, 0, 0, 0, 0},
	{"", offsetof(struct seqg_vars, event_modes[2]), "event_modes[2]", P_INT, 1, 61, 0, 0, 0, 0},
	{"", offsetof(struct seqg_vars, event_modes[3]), "event_modes[3]", P_INT, 1, 62, 0, 0, 0, 0},
	{"", offsetof(struct seqg_vars, event_modes[4]), "event_modes[4]", P_INT, 1, 63, 0, 0, 0, 0},
	{"", offsetof(struct seqg_vars, event_modes[5]), "event_modes[5]", P_INT, 1, 64, 0, 0, 0, 0},
	{"", offsetof(struct seqg_vars, event_modes[6]), "event_modes[6]", P_INT, 1, 65, 0, 0, 0, 0},
	{"", offsetof(struct seqg_vars, event_modes[7]), "event_modes[7]", P_INT, 1, 66, 0, 0, 0, 0},
	{"", offsetof(struct seqg_vars, event_modes[8]), "event_modes[8]", P_INT, 1, 67, 0, 0, 0, 0},
	{"", offsetof(struct seqg_vars, event_modes[9]), "event_modes[9]", P_INT, 1, 68, 0, 0, 0, 0},
	{"", offsetof(struct seqg_vars, event_modes[10]), "event_modes[10]", P_INT, 1, 69, 0, 0, 0, 0},
	{"", offsetof(struct seqg_vars, event_modes[11]), "event_modes[11]", P_INT, 1, 70, 0, 0, 0, 0},
	{"", offsetof(struct seqg_vars, event_modes[12]), "event_modes[12]", P_INT, 1, 71, 0, 0, 0, 0},
	{"", offsetof(struct seqg_vars, event_modes[13]), "event_modes[13]", P_INT, 1, 72, 0, 0, 0, 0},
	{"", offsetof(struct seqg_vars, event_modes[14]), "event_modes[14]", P_INT, 1, 73, 0, 0, 0, 0},
	{"", offsetof(struct seqg_vars, event_modes[15]), "event_modes[15]", P_INT, 1, 74, 0, 0, 0, 0},
	{"", offsetof(struct seqg_vars, event_modes[16]), "event_modes[16]", P_INT, 1, 75, 0, 0, 0, 0},
	{"", offsetof(struct seqg_vars, event_modes[17]), "event_modes[17]", P_INT, 1, 76, 0, 0, 0, 0},
	{"", offsetof(struct seqg_vars, event_modes[18]), "event_modes[18]", P_INT, 1, 77, 0, 0, 0, 0},
	{"", offsetof(struct seqg_vars, event_modes[19]), "event_modes[19]", P_INT, 1, 78, 0, 0, 0, 0},
	{"", offsetof(struct seqg_vars, event_ctrl[0]), "event_ctrl[0]", P_INT, 1, 79, 0, 0, 0, 0},
	{"", offsetof(struct seqg_vars, event_ctrl[1]), "event_ctrl[1]", P_INT, 1, 80, 0, 0, 0, 0},
	{"", offsetof(struct seqg_vars, event_ctrl[2]), "event_ctrl[2]", P_INT, 1, 81, 0, 0, 0, 0},
	{"", offsetof(struct seqg_vars, event_ctrl[3]), "event_ctrl[3]", P_INT, 1, 82, 0, 0, 0, 0},
	{"", offsetof(struct seqg_vars, event_ctrl[4]), "event_ctrl[4]", P_INT, 1, 83, 0, 0, 0, 0},
	{"", offsetof(struct seqg_vars, event_ctrl[5]), "event_ctrl[5]", P_INT, 1, 84, 0, 0, 0, 0},
	{"", offsetof(struct seqg_vars, event_ctrl[6]), "event_ctrl[6]", P_INT, 1, 85, 0, 0, 0, 0},
	{"", offsetof(struct seqg_vars, event_ctrl[7]), "event_ctrl[7]", P_INT, 1, 86, 0, 0, 0, 0},
	{"", offsetof(struct seqg_vars, event_ctrl[8]), "event_ctrl[8]", P_INT, 1, 87, 0, 0, 0, 0},
	{"", offsetof(struct seqg_vars, event_ctrl[9]), "event_ctrl[9]", P_INT, 1, 88, 0, 0, 0, 0},
	{"", offsetof(struct seqg_vars, event_ctrl[10]), "event_ctrl[10]", P_INT, 1, 89, 0, 0, 0, 0},
	{"", offsetof(struct seqg_vars, event_ctrl[11]), "event_ctrl[11]", P_INT, 1, 90, 0, 0, 0, 0},
	{"", offsetof(struct seqg_vars, event_ctrl[12]), "event_ctrl[12]", P_INT, 1, 91, 0, 0, 0, 0},
	{"", offsetof(struct seqg_vars, event_ctrl[13]), "event_ctrl[13]", P_INT, 1, 92, 0, 0, 0, 0},
	{"", offsetof(struct seqg_vars, event_ctrl[14]), "event_ctrl[14]", P_INT, 1, 93, 0, 0, 0, 0},
	{"", offsetof(struct seqg_vars, event_ctrl[15]), "event_ctrl[15]", P_INT, 1, 94, 0, 0, 0, 0},
	{"", offsetof(struct seqg_vars, event_ctrl[16]), "event_ctrl[16]", P_INT, 1, 95, 0, 0, 0, 0},
	{"", offsetof(struct seqg_vars, event_ctrl[17]), "event_ctrl[17]", P_INT, 1, 96, 0, 0, 0, 0},
	{"", offsetof(struct seqg_vars, event_ctrl[18]), "event_ctrl[18]", P_INT, 1, 97, 0, 0, 0, 0},
	{"", offsetof(struct seqg_vars, event_ctrl[19]), "event_ctrl[19]", P_INT, 1, 98, 0, 0, 0, 0},
	{"{device}:STOPSEQ", offsetof(struct seqg_vars, stop_pv), "stop_pv", P_INT, 1, 99, 0, 1, 0, 0},
	{"{device}:STOP_TG.PROC", offsetof(struct seqg_vars, stop_tg), "stop_tg", P_INT, 1, 100, 1, 1, 0, 0},
	{"{device}:STOPINJSEQ", offsetof(struct seqg_vars, stopinj_pv), "stopinj_pv", P_INT, 1, 101, 0, 1, 0, 0},
	{"{device}:STOPINJ_TG.PROC", offsetof(struct seqg_vars, stopinj_tg), "stopinj_tg", P_INT, 1, 102, 2, 1, 0, 0},
	{"{device}:RUNSEQ", offsetof(struct seqg_vars, run_pv), "run_pv", P_INT, 1, 103, 0, 1, 0, 0},
	{"{device}:RUN_TG.PROC", offsetof(struct seqg_vars, run_tg), "run_tg", P_INT, 1, 104, 3, 1, 0, 0},
	{"{device}:INJSEQ", offsetof(struct seqg_vars, inj_pv), "inj_pv", P_INT, 1, 105, 0, 1, 0, 0},
	{"{device}:INJ_TG.PROC", offsetof(struct seqg_vars, inj_tg), "inj_tg", P_INT, 1, 106, 4, 1, 0, 0},
	{"{device}:RESTSEQ", offsetof(struct seqg_vars, restart_pv), "restart_pv", P_INT, 1, 107, 0, 1, 0, 0},
	{"{device}:RESTART_TG.PROC", offsetof(struct seqg_vars, restart_tg), "restart_tg", P_INT, 1, 108, 5, 1, 0, 0},
	{"{device}:UPDATEEV", offsetof(struct seqg_vars, update_pv), "update_pv", P_INT, 1, 109, 0, 1, 0, 0},
	{"{device}:UPDATE_TG.PROC", offsetof(struct seqg_vars, update_tg), "update_tg", P_INT, 1, 110, 6, 1, 0, 0},
	{"{device}:PTEN", offsetof(struct seqg_vars, train_enable), "train_enable", P_INT, 1, 111, 0, 1, 0, 0},
	{"{device}:PTCNT", offsetof(struct seqg_vars, train_pulse_cnt), "train_pulse_cnt", P_INT, 1, 112, 0, 1, 0, 0},
	{"{device}:PTSIZE", offsetof(struct seqg_vars, train_pulse_size), "train_pulse_size", P_INT, 1, 113, 0, 1, 0, 0},
	{"{device}:PTTIME", offsetof(struct seqg_vars, train_start_time), "train_start_time", P_INT, 1, 114, 0, 1, 0, 0},
	{"{device}:PTCODE", offsetof(struct seqg_vars, train_pulse_code), "train_pulse_code", P_INT, 1, 115, 0, 1, 0, 0},
};

/* Event masks for state set "seq" */
static const seqMask seqg_mask_seq_0_init[] = {
	0x00000900,
	0x00000000,
	0x00000000,
	0x00000000,
};
static const seqMask seqg_mask_seq_0_Stopped[] = {
	0x00041848,
	0x00000000,
	0x00000000,
	0x00004100,
};
static const seqMask seqg_mask_seq_0_CheckSeq1Write[] = {
	0x00041800,
	0x00000000,
	0x00000000,
	0x00000000,
};
static const seqMask seqg_mask_seq_0_Running[] = {
	0x00000832,
	0x00000000,
	0x00000000,
	0x00001410,
};
static const seqMask seqg_mask_seq_0_CheckSeq2Write[] = {
	0x00040800,
	0x00000000,
	0x00000000,
	0x00000000,
};
static const seqMask seqg_mask_seq_0_Injecting[] = {
	0x00000806,
	0x00000000,
	0x00000000,
	0x00000050,
};
static const seqMask seqg_mask_seq_0_Restarting[] = {
	0x00003800,
	0x00000000,
	0x00000000,
	0x00000000,
};

/* State table for state set "seq" */
static seqState seqg_states_seq[] = {
	{
	/* state name */        "init",
	/* action function */   seqg_action_seq_0_init,
	/* event function */    seqg_event_seq_0_init,
	/* entry function */    seqg_entry_seq_0_init,
	/* exit function */     0,
	/* event mask array */  seqg_mask_seq_0_init,
	/* state options */     (0)
	},
	{
	/* state name */        "Stopped",
	/* action function */   seqg_action_seq_0_Stopped,
	/* event function */    seqg_event_seq_0_Stopped,
	/* entry function */    seqg_entry_seq_0_Stopped,
	/* exit function */     0,
	/* event mask array */  seqg_mask_seq_0_Stopped,
	/* state options */     (0)
	},
	{
	/* state name */        "CheckSeq1Write",
	/* action function */   seqg_action_seq_0_CheckSeq1Write,
	/* event function */    seqg_event_seq_0_CheckSeq1Write,
	/* entry function */    seqg_entry_seq_0_CheckSeq1Write,
	/* exit function */     0,
	/* event mask array */  seqg_mask_seq_0_CheckSeq1Write,
	/* state options */     (0)
	},
	{
	/* state name */        "Running",
	/* action function */   seqg_action_seq_0_Running,
	/* event function */    seqg_event_seq_0_Running,
	/* entry function */    seqg_entry_seq_0_Running,
	/* exit function */     0,
	/* event mask array */  seqg_mask_seq_0_Running,
	/* state options */     (0)
	},
	{
	/* state name */        "CheckSeq2Write",
	/* action function */   seqg_action_seq_0_CheckSeq2Write,
	/* event function */    seqg_event_seq_0_CheckSeq2Write,
	/* entry function */    seqg_entry_seq_0_CheckSeq2Write,
	/* exit function */     0,
	/* event mask array */  seqg_mask_seq_0_CheckSeq2Write,
	/* state options */     (0)
	},
	{
	/* state name */        "Injecting",
	/* action function */   seqg_action_seq_0_Injecting,
	/* event function */    seqg_event_seq_0_Injecting,
	/* entry function */    seqg_entry_seq_0_Injecting,
	/* exit function */     0,
	/* event mask array */  seqg_mask_seq_0_Injecting,
	/* state options */     (0)
	},
	{
	/* state name */        "Restarting",
	/* action function */   seqg_action_seq_0_Restarting,
	/* event function */    seqg_event_seq_0_Restarting,
	/* entry function */    seqg_entry_seq_0_Restarting,
	/* exit function */     0,
	/* event mask array */  seqg_mask_seq_0_Restarting,
	/* state options */     (0)
	},
};

/* Event masks for state set "reset_tg_pv" */
static const seqMask seqg_mask_reset_tg_pv_1_checking[] = {
	0x00000000,
	0x00000000,
	0x00000000,
	0x00002aa8,
};

/* State table for state set "reset_tg_pv" */
static seqState seqg_states_reset_tg_pv[] = {
	{
	/* state name */        "checking",
	/* action function */   seqg_action_reset_tg_pv_1_checking,
	/* event function */    seqg_event_reset_tg_pv_1_checking,
	/* entry function */    0,
	/* exit function */     0,
	/* event mask array */  seqg_mask_reset_tg_pv_1_checking,
	/* state options */     (0)
	},
};

/* State set table */
static seqSS seqg_statesets[] = {
	{
	/* state set name */    "seq",
	/* states */            seqg_states_seq,
	/* number of states */  7
	},

	{
	/* state set name */    "reset_tg_pv",
	/* states */            seqg_states_reset_tg_pv,
	/* number of states */  1
	},
};

/* Program table (global) */
seqProgram sncSeqRAM = {
	/* magic number */      2002001,
	/* program name */      "sncSeqRAM",
	/* channels */          seqg_chans,
	/* num. channels */     109,
	/* state sets */        seqg_statesets,
	/* num. state sets */   2,
	/* user var size */     sizeof(struct seqg_vars),
	/* param */             "",
	/* num. event flags */  6,
	/* encoded options */   (0 | OPT_CONN | OPT_NEWEF | OPT_REENT),
	/* init func */         seqg_init,
	/* entry func */        0,
	/* exit func */         0,
	/* num. queues */       0
};
# line 767 "../sncSeqRAM.stt"
//----------------------------------------
# line 768 "../sncSeqRAM.stt"
// 	  Escaped C Code Definition
# line 769 "../sncSeqRAM.stt"
//----------------------------------------
# line 771 "../sncSeqRAM.stt"

	/* 
	   Name: str2int

	   Description: Convert a string to its corresponding integer value.

	   Arguments: A string containing the representation of an integer value.

	   Return: The int value corresponding to the string representation provided.
	*/
	int str2int(char * str){

		int num = 0, i = 0;

		while(str[i] != '\0'){

			int aux = ch2int(str[i]);
			if(aux != -1){
				num *= 10;
				num += aux;
			}
			else{
				num = -1;
				break;			
			}			

			i++;
		}

		return num;
	}

	/* 
	   Name: ch2int

	   Description: Convert a char to its correponding integer value.

	   Arguments: A character to be converted.

	   Return: An int value corresponding to the char argument.
	*/
	int ch2int(char ch){

		int num = 0;

		if(ch =='0')
			num = 0;
		else if(ch == '1')
			num = 1;
		else if(ch == '2')
			num = 2;
		else if(ch == '3')
			num = 3;
		else if(ch == '4')
			num = 4;
		else if(ch == '5')
			num = 5;
		else if(ch == '6')
			num = 6;
		else if(ch == '7')
			num = 7;
		else if(ch == '8')
			num = 8;
		else if(ch == '9')
			num = 9;
		else
			num = -1;

		return num;	
	}

	/*
	   Name: init_EventPointerArray

	   Description: Initializes the array of pointers EventPointerArray using an array of Events.
			The addresses of the EventArray elements become the elements of the pointer array.

	   Arguments: The number of elements in EventPointerArray (equal to EventArray).
	*/
	void init_EventPointerArray(int size){

		int i;

		for(i = 0; i < size; i++){

			EventPointerArray[i] = &EventArray[i];
		}
	}

	/*
	   Name: bubbleSort

	   Description: Sort an array of pointers to Event in ascending order using the Event->timestamp field.
			The algorithm used is bubble sort. A check is included that stop sorting if array is sorted.
			When equal timestamps are found, the event of higher index has its timestamp increased by 1.

	   Arguments: First argument is a pointer to the array to be sorted, second argument is the array size.

	   Return: 0-> Fail, 1-> Success.
	*/
	int bubbleSort(Event* * evArray, int arraySize){

		int sorted = 0;
		int a, b;

		if(evArray == NULL){

			printf("Can't sort Event Array. Event array is null.\n");
			
			// Fail
			return 0;
		}

		// Index of sorted array
		for (a = 0; a < arraySize - 1; a++){

			sorted = 1;			

			// Scan array backward
			for (b = arraySize - 1; b > a; b--){
				
				// swap unordered neighbors
				if (evArray[b-1]->timestamp > evArray[b]->timestamp){ 

					swap(&evArray[b-1], &evArray[b]);
					sorted = 0;
				}

				// handle equal timestamps
				if(evArray[b-1]->timestamp == evArray[b]->timestamp){

					evArray[b]->timestamp += 1;
					sorted = 0;
				}
			}

			// Check if array had no swaps (is ordered)
			if(sorted)
				break;
		}	

		// Success
		return 1;
	}

	/*
	   Name: swap

	   Description: Swap two elements containing pointers to Event.

	   Arguments: First argument is a pointer to the first pointer element.
		      Second argument is a pointer to the second pointer element.
	*/
	void swap(Event* *a, Event* *b){

		Event * tmp;
		tmp = *a;
		*a = *b;
		*b = tmp;
	}
	/*
	   Name: updateEventPointerArray

	   Description: Updates the EventPointerArray with the updated event information obtained with pvGet.
			The array is also ordered in ascending order.

	   Arguments: First argument is the number of Events pointed to by EventPointerArray.
		      Following arguments are updated code, timestamp, mode, and control arrays.   
	*/
	void updateEventPointerArray(int evNumber, int * code_arr,
				 int * time_arr, int * mode_arr, int * control_arr){

		int i;

		// Copy Events to array
		for(i = 0; i < evNumber; i++){
				
			EventPointerArray[i]->code = code_arr[i];
			EventPointerArray[i]->timestamp = time_arr[i];
			EventPointerArray[i]->mode = mode_arr[i];
			EventPointerArray[i]->ctrl = control_arr[i];
		}

		// Sort events by timestamp in ascending order
		bubbleSort(EventPointerArray, evNumber);
	}

	/*
	   Name: seqOneWrite

	   Description: Writes to SequenceRAM 1 the events configured as ALWAYS.
			The event information is acquired from EventPointerArray.
			Checks if seqRAM pointer is pointing to the address it was supposed to at the end.
			The seqtime record is responsible for triggering the hardware write when processed.

	   Arguments: First argument is the total number of events after expansion.
		      Second argument is the calling state set.
		      Next four arguments are pointers to variables seqaddr, seqcode, seqtime, and seqcount.
		      Following four arguments are the VAR_IDs of the variables seqaddr, seqcode, seqtime, and seqcount.

	   Return: Number of write operations performed.	   
	*/
	int seqOneWrite(int evnum, SS_ID ssId, int *pseqaddr, int *pseqcode, int *pseqtime, int *pseqcount,
				VAR_ID seqaddr_id, VAR_ID seqcode_id, VAR_ID seqtime_id, VAR_ID seqcount_id){
											
		int i, maxdelay = 0, address = 0;

		// timestamp offset for code 0x7F from previous timestamp
		int offSetEndCode = 10;

		for(i = 0; i < evnum; i++){

			// jump non-always events
			if(ExpandedEventArray[i].ctrl != ALWAYS)
				continue;

			// define address, get code and timestamp
			*pseqaddr = address;
			*pseqcode = ExpandedEventArray[i].code;
			*pseqtime = maxdelay = ExpandedEventArray[i].timestamp;

			// write event info to seqRAM records
			seq_pvPut(ssId, seqaddr_id, SYNC);
			seq_pvPut(ssId, seqcode_id, SYNC);

			// write timestamp (wich also triggers write to seqRAM)
			seq_pvPut(ssId, seqtime_id, SYNC);

			////////////// D E B U G G I N G //////////////////////////////////////////

			printf("Write to SeqRAM 1-> seqaddr= %d, seqcode= %d, seqtime= %d\n", *pseqaddr, *pseqcode, *pseqtime);

			///////////////////////////////////////////////////////////////////////////

			// point to next address
			address++;
		}

	      // Send 0x7F code

		// define address, get code and timestamp
		*pseqaddr = address;
		*pseqcode = 0x7F;
		*pseqtime = maxdelay + offSetEndCode;

		// write event info to seqRAM records
		seq_pvPut(ssId, seqaddr_id, SYNC);
		seq_pvPut(ssId, seqcode_id, SYNC);

		// write timestamp (wich also triggers write to seqRAM)
		seq_pvPut(ssId, seqtime_id, SYNC);

		////////////// D E B U G G I N G //////////////////////////////////////////

		printf("Write to SeqRAM 1-> seqaddr= %d, seqcode= %d, seqtime= %d\n", *pseqaddr, *pseqcode, *pseqtime);

		///////////////////////////////////////////////////////////////////////////


		// point to next address
		address++;

		// return number of writes to SeqRAM
	     	return address;
	}

	/*
	   Name: seqTwoWrite

	   Description: Writes to SequenceRAM 2 the events configured as INJECTION.
			The event information is acquired from EventPointerArray.
			Checks if seqRAM pointer is pointing to the address it was supposed to at the end.
			The seqtime record is responsible for triggering the hardware write when processed.

	   Arguments: First argument is total number of events (ALWAYS and INJECTION).
		      Second argument is the bucket array.
		      Third argument is the length of the bucket array.
		      Next four arguments are pointers to variables seqaddr, seqcode, seqtime, and seqcount.
		      Following four arguments are the VAR_IDs of the variables seqaddr, seqcode, seqtime, and seqcount.

	   Return: Number of write operations performed.	   
	*/
	int seqTwoWrite(int evnum, int TBL[], int length, SS_ID ssId, int *pseqaddr, int *pseqcode,
 		int *pseqtime, int *pseqcount, VAR_ID seqaddr_id, VAR_ID seqcode_id, VAR_ID seqtime_id, VAR_ID seqcount_id){
									
		int i, j, seqdly, rfdly, maxdelay = 0, address = 0;

		// timestamp offset for code 0x7E or 0x70 from previous timestamp
		int offSetEndCode = 10;

		// timestamp for sending the RF delay code to modules
		int RFDlyTimestamp = 10;

		// for each bucket
		for(i = 0; i < length; i++){

			// Send appropriate RF delay for modules
			seqdly = TBL[i] / 4;
			rfdly = TBL[i] % 4;

			// Set RF Delay Code (code = 0x40 + rfdly)

			*pseqaddr = address;
			*pseqcode = 0x40 + rfdly * 5;
			*pseqtime = RFDlyTimestamp;

			// write event info to seqRAM records
			seq_pvPut(ssId, seqaddr_id, SYNC);
			seq_pvPut(ssId, seqcode_id, SYNC);

			// write timestamp (wich also triggers write to seqRAM)
			seq_pvPut(ssId, seqtime_id, SYNC);

			////////////// D E B U G G I N G //////////////////////////////////////////

			printf("Write to SeqRAM 2-> seqaddr= %d, seqcode= %d, seqtime= %d\n", *pseqaddr, *pseqcode, *pseqtime);

			///////////////////////////////////////////////////////////////////////////


			// point to next address
			address++;

			// write events
			for(j = 0; j < evnum; j++){

				// INJECTION
				if(ExpandedEventArray[j].mode == INCR){			

					// Set timestamp WITH seqdly
					*pseqtime = maxdelay = ExpandedEventArray[j].timestamp + seqdly;
				}
				else{

					// Set timestamp WITHOUT seqdly
					*pseqtime = maxdelay = ExpandedEventArray[j].timestamp;
				}
				

			      // Write Specified Code 
				// specify address and code (timestamp was specified above)
				*pseqaddr = address;
				*pseqcode = ExpandedEventArray[j].code;

				// write event info to seqRAM records
				seq_pvPut(ssId, seqaddr_id, SYNC);	
				seq_pvPut(ssId, seqcode_id, SYNC);
	
				// write timestamp (wich also triggers write to seqRAM)
				seq_pvPut(ssId, seqtime_id, SYNC);

				////////////// D E B U G G I N G //////////////////////////////////////////

				printf("Write to SeqRAM 2-> seqaddr= %d, seqcode= %d, seqtime= %d\n", *pseqaddr, *pseqcode, *pseqtime);

				///////////////////////////////////////////////////////////////////////////


				// point to next address
				address++;
				
			}

		        // SequenceRAM Wait code 
			if(i < length - 1){

				*pseqcode = 0x70; // Send 0x70 code
				
				// define address and timestamp
				*pseqaddr = address;
				*pseqtime = maxdelay + offSetEndCode;
	
				// write event info to seqRAM records
				seq_pvPut(ssId, seqaddr_id, SYNC);
				seq_pvPut(ssId, seqcode_id, SYNC);

				// write timestamp (wich also triggers write to seqRAM)
				seq_pvPut(ssId, seqtime_id, SYNC);

				////////////// D E B U G G I N G //////////////////////////////////////////

				printf("Write to SeqRAM 2-> seqaddr= %d, seqcode= %d, seqtime= %d\n", *pseqaddr, *pseqcode, *pseqtime);

				///////////////////////////////////////////////////////////////////////////


				// point to next address
				address++;		
			}	
		}    

		// SequenceRAM Switch RAM code 
		*pseqcode = 0x7E; // Send 0x7E code
		
		// define address and timestamp
		*pseqaddr = address;
		*pseqtime = maxdelay + offSetEndCode;
	
		// write event info to seqRAM records
		seq_pvPut(ssId, seqaddr_id, SYNC);
		seq_pvPut(ssId, seqcode_id, SYNC);

		// write timestamp (wich also triggers write to seqRAM)
		seq_pvPut(ssId, seqtime_id, SYNC);

		////////////// D E B U G G I N G //////////////////////////////////////////

		printf("Write to SeqRAM 2-> seqaddr= %d, seqcode= %d, seqtime= %d\n", *pseqaddr, *pseqcode, *pseqtime);

		///////////////////////////////////////////////////////////////////////////

		// point to next address
		address++;

		// return number of writes to SeqRAM
	        return address;
	}

	/*
	   Name: expandArray

	   Description: Fill the ExpandedEventArray with an expansion of the event pointer array.
			This function is used as means to include a pulse train to the events to be written.

	   Arguments: First argument is the number of common events.
		      The next five arguments are enable, count, size, initial timestamp, and code properties of the pulse train.

	   Return: Total number of events after expansion.	   
	*/
	int expandArray(int evnum, int trainEnable, int pulseCnt, int trainDuration, int trainStart, int trainCode){

		int i, j;

		// Expanded array index
		int expIndex = 0;

		// Pulse train variables
		int pulseInterval = trainDuration / pulseCnt;
		int pulseTime = trainStart;
		int pulsesLeft = 0;

		// If pulse train is disabled
		if(trainEnable == 0 || pulseCnt == 0){

			// Copy common events to expanded array
			for(i = 0; i < evnum; i++){

				ExpandedEventArray[expIndex].code = EventPointerArray[i]->code;
				ExpandedEventArray[expIndex].timestamp = EventPointerArray[i]->timestamp;
				ExpandedEventArray[expIndex].mode = EventPointerArray[i]->mode;
				ExpandedEventArray[expIndex].ctrl = EventPointerArray[i]->ctrl;

				expIndex++;
			}

			// return number of events after expansion
			return expIndex;
		}

		
		// Copy events to expanded array
		for(i = 0; i < evnum; i++){

			// Detect beginning of pulse train
			if(trainStart == pulseTime && EventPointerArray[i]->timestamp > trainStart){

				pulsesLeft = pulseCnt;
			}

			// Insert pulses if necessary
			if(pulsesLeft > 0){

				// calculate num of pulses to insert

				int n = 0;

				if(pulseTime < EventPointerArray[i]->timestamp)
					n = floor((EventPointerArray[i]->timestamp - pulseTime) / pulseInterval) + 1;

				if(n > pulsesLeft) n = pulsesLeft;

				// insert pulses
				for(j = 0; j < n; j++){

					ExpandedEventArray[expIndex].code = trainCode;

					ExpandedEventArray[expIndex].timestamp = pulseTime;
					pulseTime += pulseInterval;

					ExpandedEventArray[expIndex].mode = INCR;
					ExpandedEventArray[expIndex].ctrl = ALWAYS;

					// next array index
					expIndex++;
				}

				// update pulses left
				pulsesLeft -= n;
			}

			// Insert common event
			ExpandedEventArray[expIndex].code = EventPointerArray[i]->code;
			ExpandedEventArray[expIndex].timestamp = EventPointerArray[i]->timestamp;
			ExpandedEventArray[expIndex].mode = EventPointerArray[i]->mode;
			ExpandedEventArray[expIndex].ctrl = EventPointerArray[i]->ctrl;

			// next array index
			expIndex++;
		}

		// Detect if the pulse train didn't start
		if(trainStart == pulseTime)
			pulsesLeft = pulseCnt;

		// Insert remaining pulses
		for(i = 0; i < pulsesLeft; i++){

			ExpandedEventArray[expIndex].code = trainCode;
			ExpandedEventArray[expIndex].timestamp = pulseTime;
			pulseTime += pulseInterval;
			ExpandedEventArray[expIndex].mode = INCR;
			ExpandedEventArray[expIndex].ctrl = ALWAYS;

			// next array index
			expIndex++;
		}
		
		// return number of events after expansion
		return expIndex;
	}

	/*
	   Name: trainStartCorrection

	   Description: Redefine the pulse train starting timestamp so there are no conflicts with other events.

	   Arguments: First argument is the pulse train starting timestamp.
		      Second argument is the pulse train duration. 
		      Third argument is the pulse count of pulse train.
		      Fourth argument is the number of events.

	   Return: The corrected pulse train starting timestamp.	   
	*/
	int trainStartCorrection(int trainEnable, int trainStart, int trainDuration, int pulseCnt, int evnum) {

		if(!trainEnable) return trainStart;

		int i;

		int interval = trainDuration/pulseCnt;

    		for(i = evnum-1; i >= 0; i--){

			int diff = EventPointerArray[i]->timestamp - trainStart;

			if(diff >= 0 && !(diff % interval))
				trainStart--;
		}

		// guarantee the timestamp is not negative
		if(trainStart < 0) trainStart = 0;

		// return new starting timestamp
		return trainStart;
	}

	/*
	   Name: updateExpandedArray

	   Description: Update expanded array.

	   Arguments: First argument is the enable parameter of pulse train event.
		      Second argument is the pulse train start timestamp.
		      Third argument is the pulse train duration.
		      Fourth argument is the pulse train count of pulses.
		      Fifth argument is the pulse train code.
		      Sixth argument is the number of common events.		      

	   Return: The corrected pulse train starting timestamp.	   
	*/
	int updateExpandedArray(int trainEnable, int trainStart, int trainDuration, int pulseCnt, int trainCode, int evnum){

		// adjust timestamp for pulse train
		trainStart = trainStartCorrection(trainEnable, trainStart, trainDuration, pulseCnt, evnum);

		// expand array of events and put it into expEvArray
		int newNumEvents = expandArray(evnum, trainEnable, pulseCnt, trainDuration, trainStart, trainCode);

		return newNumEvents;		
	}


/* Register sequencer commands and program */
#include "epicsExport.h"
static void sncSeqRAMRegistrar (void) {
    seqRegisterSequencerCommands();
    seqRegisterSequencerProgram (&sncSeqRAM);
}
epicsExportRegistrar(sncSeqRAMRegistrar);
