/* C code for program sncSeqRAM, generated by snc from ./../sncSeqRAM.stt */
#include <string.h>
#include <stddef.h>
#include <stdio.h>
#include <limits.h>

#include "seq_snc.h"
# line 88 "./../sncSeqRAM.stt"
static const EF_ID stopFlag = 1;
# line 98 "./../sncSeqRAM.stt"
static const EF_ID stopInjFlag = 2;
# line 108 "./../sncSeqRAM.stt"
static const EF_ID runFlag = 3;
# line 118 "./../sncSeqRAM.stt"
static const EF_ID injFlag = 4;
# line 128 "./../sncSeqRAM.stt"
static const EF_ID restFlag = 5;
# line 138 "./../sncSeqRAM.stt"
static const EF_ID updateFlag = 6;
# line 169 "./../sncSeqRAM.stt"
#include <stdlib.h>
# line 170 "./../sncSeqRAM.stt"
#include <math.h>
# line 172 "./../sncSeqRAM.stt"




    typedef enum{
 FIX = 0,
 INCR = 1
    } evmode;


    typedef enum{
 ALWAYS = 0,
 INJECTION = 1
    } evctrl;


    typedef struct Event{
 int code;
 int timestamp;
 evmode mode;
 evctrl ctrl;
    } Event;




    Event * EventPointerArray[20];

    Event EventArray[20];

    const int sizeOfArrays = 20;

    Event ExpandedEventArray[2090];

    const int sizeOfExpArray = 2090;


    int str2int(char * str);
    int ch2int(char ch);
    void init_EventPointerArray(int size);
    int bubbleSort(Event * * evArray, int arraySize);
    void swap(Event* *a, Event* *b);
    void updateEventPointerArray(int evNumber, int * code_arr,
     int * time_arr, int * mode_arr, int * control_arr);
    int seqOneWrite(int evnum, SS_ID ssId, int *pseqaddr, int *pseqcode, int *pseqtime, int *pseqcount,
     VAR_ID seqaddr_id, VAR_ID seqcode_id, VAR_ID seqtime_id, VAR_ID seqcount_id);

    int seqTwoWrite(int evnum, int TBL[], int length, SS_ID ssId, int *pseqaddr, int *pseqcode, int *pseqtime, int *pseqcount,
      VAR_ID seqaddr_id, VAR_ID seqcode_id, VAR_ID seqtime_id, VAR_ID seqcount_id);

    int expandArray(int evnum, int trainEnable, int pulseCnt, int trainDuration, int trainStart, int trainCode);
    int trainStartCorrection(int trainEnable, int trainStart, int trainDuration, int pulseCnt, int evnum);
    int updateExpandedArray(int trainEnable, int trainStart, int trainDuration, int pulseCnt, int trainCode, int evnum);


/* Variable declarations */
# line 10 "./../sncSeqRAM.stt"
static	int eventNum;
# line 11 "./../sncSeqRAM.stt"
static	int expandedEventNum;
# line 12 "./../sncSeqRAM.stt"
static	char *device;
# line 13 "./../sncSeqRAM.stt"
static	char *evCodeName;
# line 14 "./../sncSeqRAM.stt"
static	char *evTimeName;
# line 15 "./../sncSeqRAM.stt"
static	char *evModeName;
# line 16 "./../sncSeqRAM.stt"
static	char *evCtrlName;
# line 17 "./../sncSeqRAM.stt"
static	char str[40];
# line 18 "./../sncSeqRAM.stt"
static	int i;
# line 19 "./../sncSeqRAM.stt"
static	int numberOfWrites;
# line 25 "./../sncSeqRAM.stt"
static	int StateMachineStatus;
# line 32 "./../sncSeqRAM.stt"
static	int network;
# line 36 "./../sncSeqRAM.stt"
static	int tbl[2000];
# line 39 "./../sncSeqRAM.stt"
static	int tbl_length;
# line 42 "./../sncSeqRAM.stt"
static	int seqs;
# line 46 "./../sncSeqRAM.stt"
static	int seqen_rbv;
# line 50 "./../sncSeqRAM.stt"
static	int seqen;
# line 52 "./../sncSeqRAM.stt"
static	int seqsw;
# line 54 "./../sncSeqRAM.stt"
static	int seqaddr;
# line 56 "./../sncSeqRAM.stt"
static	int seqcode;
# line 58 "./../sncSeqRAM.stt"
static	int seqtime;
# line 61 "./../sncSeqRAM.stt"
static	int seqcount;
# line 65 "./../sncSeqRAM.stt"
static	int event_codes[20];
# line 68 "./../sncSeqRAM.stt"
static	int event_timestamps[20];
# line 71 "./../sncSeqRAM.stt"
static	int event_modes[20];
# line 74 "./../sncSeqRAM.stt"
static	int event_ctrl[20];
# line 81 "./../sncSeqRAM.stt"
static	int stop_pv;
# line 85 "./../sncSeqRAM.stt"
static	int stop_tg;
# line 91 "./../sncSeqRAM.stt"
static	int stopinj_pv;
# line 95 "./../sncSeqRAM.stt"
static	int stopinj_tg;
# line 101 "./../sncSeqRAM.stt"
static	int run_pv;
# line 105 "./../sncSeqRAM.stt"
static	int run_tg;
# line 111 "./../sncSeqRAM.stt"
static	int inj_pv;
# line 115 "./../sncSeqRAM.stt"
static	int inj_tg;
# line 121 "./../sncSeqRAM.stt"
static	int restart_pv;
# line 125 "./../sncSeqRAM.stt"
static	int restart_tg;
# line 131 "./../sncSeqRAM.stt"
static	int update_pv;
# line 135 "./../sncSeqRAM.stt"
static	int update_tg;
# line 145 "./../sncSeqRAM.stt"
static	int train_enable;
# line 149 "./../sncSeqRAM.stt"
static	int train_pulse_cnt;
# line 153 "./../sncSeqRAM.stt"
static	int train_pulse_size;
# line 157 "./../sncSeqRAM.stt"
static	int train_start_time;
# line 161 "./../sncSeqRAM.stt"
static	int train_pulse_code;


/* Function declarations */

#define seqg_var (*(struct seqg_vars *const *)seqg_env)

/* Program init func */
static void seqg_init(PROG_ID seqg_env)
{
	{
# line 13 "./../sncSeqRAM.stt"
	static char *seqg_initvar_evCodeName = "EVCODE";
	memcpy(&evCodeName, &seqg_initvar_evCodeName, sizeof(seqg_initvar_evCodeName));
	}
	{
# line 14 "./../sncSeqRAM.stt"
	static char *seqg_initvar_evTimeName = "EVTIME";
	memcpy(&evTimeName, &seqg_initvar_evTimeName, sizeof(seqg_initvar_evTimeName));
	}
	{
# line 15 "./../sncSeqRAM.stt"
	static char *seqg_initvar_evModeName = "EVDLYMODE";
	memcpy(&evModeName, &seqg_initvar_evModeName, sizeof(seqg_initvar_evModeName));
	}
	{
# line 16 "./../sncSeqRAM.stt"
	static char *seqg_initvar_evCtrlName = "EVTRANSM";
	memcpy(&evCtrlName, &seqg_initvar_evCtrlName, sizeof(seqg_initvar_evCtrlName));
	}
}

/****** Code for state "init" in state set "seq" ******/

/* Entry function for state "init" in state set "seq" */
static void seqg_entry_seq_0_init(SS_ID seqg_env)
{
	/* C code definitions */
# line 237 "./../sncSeqRAM.stt"
	



      
# line 244 "./../sncSeqRAM.stt"
	StateMachineStatus = 0;
# line 245 "./../sncSeqRAM.stt"
	numberOfWrites = 0;
# line 246 "./../sncSeqRAM.stt"
	expandedEventNum = 0;
# line 249 "./../sncSeqRAM.stt"
	eventNum = str2int(seq_macValueGet(seqg_env, "ev_num"));
# line 250 "./../sncSeqRAM.stt"
	device = seq_macValueGet(seqg_env, "device");
# line 253 "./../sncSeqRAM.stt"
	for (i = 0; i < eventNum; i++)
	{
# line 254 "./../sncSeqRAM.stt"
		sprintf(str, "%s:%s%d", device, evCodeName, i);
# line 255 "./../sncSeqRAM.stt"
		seq_pvAssign(seqg_env, 12/*event_codes*/ + (CH_ID)(i), str);
# line 256 "./../sncSeqRAM.stt"
		printf("%s\n", str);
	}
# line 258 "./../sncSeqRAM.stt"
	for (i = 0; i < eventNum; i++)
	{
# line 259 "./../sncSeqRAM.stt"
		sprintf(str, "%s:%s%d", device, evTimeName, i);
# line 260 "./../sncSeqRAM.stt"
		seq_pvAssign(seqg_env, 32/*event_timestamps*/ + (CH_ID)(i), str);
	}
# line 262 "./../sncSeqRAM.stt"
	for (i = 0; i < eventNum; i++)
	{
# line 263 "./../sncSeqRAM.stt"
		sprintf(str, "%s:%s%d", device, evModeName, i);
# line 264 "./../sncSeqRAM.stt"
		seq_pvAssign(seqg_env, 52/*event_modes*/ + (CH_ID)(i), str);
	}
# line 266 "./../sncSeqRAM.stt"
	for (i = 0; i < eventNum; i++)
	{
# line 267 "./../sncSeqRAM.stt"
		sprintf(str, "%s:%s%d", device, evCtrlName, i);
# line 268 "./../sncSeqRAM.stt"
		seq_pvAssign(seqg_env, 72/*event_ctrl*/ + (CH_ID)(i), str);
	}
# line 272 "./../sncSeqRAM.stt"
	init_EventPointerArray(eventNum);
# line 275 "./../sncSeqRAM.stt"
	for (i = 0; i < eventNum; i++)
	{
# line 277 "./../sncSeqRAM.stt"
		seq_pvGetTmo(seqg_env, 12/*event_codes*/ + (CH_ID)(i), SYNC, DEFAULT_TIMEOUT);
# line 278 "./../sncSeqRAM.stt"
		seq_pvGetTmo(seqg_env, 32/*event_timestamps*/ + (CH_ID)(i), SYNC, DEFAULT_TIMEOUT);
# line 279 "./../sncSeqRAM.stt"
		seq_pvGetTmo(seqg_env, 52/*event_modes*/ + (CH_ID)(i), SYNC, DEFAULT_TIMEOUT);
# line 280 "./../sncSeqRAM.stt"
		seq_pvGetTmo(seqg_env, 72/*event_ctrl*/ + (CH_ID)(i), SYNC, DEFAULT_TIMEOUT);
	}
# line 284 "./../sncSeqRAM.stt"
	updateEventPointerArray(eventNum, event_codes, event_timestamps, event_modes, event_ctrl);
# line 288 "./../sncSeqRAM.stt"
	expandedEventNum = updateExpandedArray(train_enable, train_start_time, train_pulse_size, train_pulse_cnt, train_pulse_code, eventNum);
# line 290 "./../sncSeqRAM.stt"
	printf("Initialization Entry\n");
}

/* Event function for state "init" in state set "seq" */
static seqBool seqg_event_seq_0_init(SS_ID seqg_env, int *seqg_ptrn, int *seqg_pnst)
{
# line 293 "./../sncSeqRAM.stt"
	if (seqs == 0 && network == 1)
	{
		*seqg_pnst = 1;
		*seqg_ptrn = 0;
		return TRUE;
	}
# line 300 "./../sncSeqRAM.stt"
	if (seqs == 1 && network == 1)
	{
		*seqg_pnst = 3;
		*seqg_ptrn = 1;
		return TRUE;
	}
# line 307 "./../sncSeqRAM.stt"
	if (seqs == 2 && network == 1)
	{
		*seqg_pnst = 5;
		*seqg_ptrn = 2;
		return TRUE;
	}
	return FALSE;
}

/* Action function for state "init" in state set "seq" */
static void seqg_action_seq_0_init(SS_ID seqg_env, int seqg_trn, int *seqg_pnst)
{
	switch(seqg_trn)
	{
	case 0:
		{
			/* C code definitions */
# line 295 "./../sncSeqRAM.stt"
			 
# line 297 "./../sncSeqRAM.stt"
			printf("Moving to Stopped State\n");
		}
		return;
	case 1:
		{
			/* C code definitions */
# line 302 "./../sncSeqRAM.stt"
			 
# line 304 "./../sncSeqRAM.stt"
			printf("Moving to Running State\n");
		}
		return;
	case 2:
		{
			/* C code definitions */
# line 309 "./../sncSeqRAM.stt"
			 
# line 311 "./../sncSeqRAM.stt"
			printf("Moving to Injecting State\n");
		}
		return;
	}
}

/****** Code for state "Stopped" in state set "seq" ******/

/* Entry function for state "Stopped" in state set "seq" */
static void seqg_entry_seq_0_Stopped(SS_ID seqg_env)
{
	/* C code definitions */
# line 318 "./../sncSeqRAM.stt"
	







      
# line 329 "./../sncSeqRAM.stt"
	StateMachineStatus = 1;
# line 330 "./../sncSeqRAM.stt"
	seq_pvPutTmo(seqg_env, 0/*StateMachineStatus*/, SYNC, DEFAULT_TIMEOUT);
# line 333 "./../sncSeqRAM.stt"
	seq_efClear(seqg_env, runFlag);
# line 334 "./../sncSeqRAM.stt"
	seq_efClear(seqg_env, updateFlag);
# line 337 "./../sncSeqRAM.stt"
	for (i = 0; i < eventNum; i++)
	{
# line 339 "./../sncSeqRAM.stt"
		seq_pvGetTmo(seqg_env, 12/*event_codes*/ + (CH_ID)(i), SYNC, DEFAULT_TIMEOUT);
# line 340 "./../sncSeqRAM.stt"
		seq_pvGetTmo(seqg_env, 32/*event_timestamps*/ + (CH_ID)(i), SYNC, DEFAULT_TIMEOUT);
# line 341 "./../sncSeqRAM.stt"
		seq_pvGetTmo(seqg_env, 52/*event_modes*/ + (CH_ID)(i), SYNC, DEFAULT_TIMEOUT);
# line 342 "./../sncSeqRAM.stt"
		seq_pvGetTmo(seqg_env, 72/*event_ctrl*/ + (CH_ID)(i), SYNC, DEFAULT_TIMEOUT);
	}
# line 346 "./../sncSeqRAM.stt"
	updateEventPointerArray(eventNum, event_codes, event_timestamps, event_modes, event_ctrl);
# line 350 "./../sncSeqRAM.stt"
	expandedEventNum = updateExpandedArray(train_enable, train_start_time, train_pulse_size, train_pulse_cnt, train_pulse_code, eventNum);
# line 355 "./../sncSeqRAM.stt"
	seqen = 0;
# line 356 "./../sncSeqRAM.stt"
	seq_pvPutTmo(seqg_env, 6/*seqen*/, SYNC, DEFAULT_TIMEOUT);
# line 359 "./../sncSeqRAM.stt"
	numberOfWrites = 0;
# line 361 "./../sncSeqRAM.stt"
	printf("Stopped Entry\n");
}

/* Event function for state "Stopped" in state set "seq" */
static seqBool seqg_event_seq_0_Stopped(SS_ID seqg_env, int *seqg_ptrn, int *seqg_pnst)
{
# line 364 "./../sncSeqRAM.stt"
	if (seqen_rbv == 0 && seqcount != 0)
	{
		*seqg_pnst = 1;
		*seqg_ptrn = 0;
		return TRUE;
	}
# line 373 "./../sncSeqRAM.stt"
	if (seq_efTestAndClear(seqg_env, updateFlag) && update_tg)
	{
		*seqg_pnst = 1;
		*seqg_ptrn = 1;
		return TRUE;
	}
# line 404 "./../sncSeqRAM.stt"
	if (seq_efTestAndClear(seqg_env, runFlag) && run_tg && (seqcount == 0))
	{
		*seqg_pnst = 2;
		*seqg_ptrn = 2;
		return TRUE;
	}
# line 418 "./../sncSeqRAM.stt"
	if (seqs == 1)
	{
		*seqg_pnst = 3;
		*seqg_ptrn = 3;
		return TRUE;
	}
	return FALSE;
}

/* Action function for state "Stopped" in state set "seq" */
static void seqg_action_seq_0_Stopped(SS_ID seqg_env, int seqg_trn, int *seqg_pnst)
{
	switch(seqg_trn)
	{
	case 0:
		{
			/* C code definitions */
# line 366 "./../sncSeqRAM.stt"
			 
# line 368 "./../sncSeqRAM.stt"
			seqsw = 1;
# line 369 "./../sncSeqRAM.stt"
			seq_pvPutTmo(seqg_env, 7/*seqsw*/, SYNC, DEFAULT_TIMEOUT);
		}
		return;
	case 1:
		{
			/* C code definitions */
# line 375 "./../sncSeqRAM.stt"
			 
# line 378 "./../sncSeqRAM.stt"
			StateMachineStatus = 5;
# line 379 "./../sncSeqRAM.stt"
			seq_pvPutTmo(seqg_env, 0/*StateMachineStatus*/, SYNC, DEFAULT_TIMEOUT);
# line 382 "./../sncSeqRAM.stt"
			for (i = 0; i < eventNum; i++)
			{
# line 384 "./../sncSeqRAM.stt"
				seq_pvGetTmo(seqg_env, 12/*event_codes*/ + (CH_ID)(i), SYNC, DEFAULT_TIMEOUT);
# line 385 "./../sncSeqRAM.stt"
				seq_pvGetTmo(seqg_env, 32/*event_timestamps*/ + (CH_ID)(i), SYNC, DEFAULT_TIMEOUT);
# line 386 "./../sncSeqRAM.stt"
				seq_pvGetTmo(seqg_env, 52/*event_modes*/ + (CH_ID)(i), SYNC, DEFAULT_TIMEOUT);
# line 387 "./../sncSeqRAM.stt"
				seq_pvGetTmo(seqg_env, 72/*event_ctrl*/ + (CH_ID)(i), SYNC, DEFAULT_TIMEOUT);
			}
# line 391 "./../sncSeqRAM.stt"
			updateEventPointerArray(eventNum, event_codes, event_timestamps, event_modes, event_ctrl);
# line 395 "./../sncSeqRAM.stt"
			expandedEventNum = updateExpandedArray(train_enable, train_start_time, train_pulse_size, train_pulse_cnt, train_pulse_code, eventNum);
# line 398 "./../sncSeqRAM.stt"
			StateMachineStatus = 1;
# line 399 "./../sncSeqRAM.stt"
			seq_pvPutTmo(seqg_env, 0/*StateMachineStatus*/, SYNC, DEFAULT_TIMEOUT);
# line 401 "./../sncSeqRAM.stt"
			printf("Update Finished\n");
		}
		return;
	case 2:
		{
			/* C code definitions */
# line 406 "./../sncSeqRAM.stt"
			 
# line 409 "./../sncSeqRAM.stt"
			StateMachineStatus = 6;
# line 410 "./../sncSeqRAM.stt"
			seq_pvPutTmo(seqg_env, 0/*StateMachineStatus*/, SYNC, DEFAULT_TIMEOUT);
# line 413 "./../sncSeqRAM.stt"
			numberOfWrites = seqOneWrite(expandedEventNum, ssId, &seqaddr, &seqcode, &seqtime, &seqcount, seq_pvIndex(seqg_env, 8/*seqaddr*/), seq_pvIndex(seqg_env, 9/*seqcode*/), seq_pvIndex(seqg_env, 10/*seqtime*/), seq_pvIndex(seqg_env, 11/*seqcount*/));
# line 415 "./../sncSeqRAM.stt"
			printf("Run Triggered\n");
		}
		return;
	case 3:
		{
			/* C code definitions */
# line 420 "./../sncSeqRAM.stt"
			 
# line 422 "./../sncSeqRAM.stt"
			printf("Moving to Running State\n");
		}
		return;
	}
}

/****** Code for state "CheckSeq1Write" in state set "seq" ******/

/* Entry function for state "CheckSeq1Write" in state set "seq" */
static void seqg_entry_seq_0_CheckSeq1Write(SS_ID seqg_env)
{
	/* C code definitions */
# line 430 "./../sncSeqRAM.stt"
	

       
# line 434 "./../sncSeqRAM.stt"
	printf("CheckSeq1Write Entry\n");
# line 436 "./../sncSeqRAM.stt"
	printf("Debugging EVG:seqen: numberOfWrites= %d, seqcount= %d, seqen_rbv= %d, seqs=%d\n", numberOfWrites, seqcount, seqen_rbv, seqs);
}

/* Event function for state "CheckSeq1Write" in state set "seq" */
static seqBool seqg_event_seq_0_CheckSeq1Write(SS_ID seqg_env, int *seqg_ptrn, int *seqg_pnst)
{
# line 439 "./../sncSeqRAM.stt"
	if (seqcount == numberOfWrites && seqen_rbv == 0)
	{
		*seqg_pnst = 2;
		*seqg_ptrn = 0;
		return TRUE;
	}
# line 455 "./../sncSeqRAM.stt"
	if (seqs == 1)
	{
		*seqg_pnst = 3;
		*seqg_ptrn = 1;
		return TRUE;
	}
# line 464 "./../sncSeqRAM.stt"
	if (seq_delay(seqg_env, 5.0) && seqen_rbv == 0)
	{
		*seqg_pnst = 1;
		*seqg_ptrn = 2;
		return TRUE;
	}
	return FALSE;
}

/* Action function for state "CheckSeq1Write" in state set "seq" */
static void seqg_action_seq_0_CheckSeq1Write(SS_ID seqg_env, int seqg_trn, int *seqg_pnst)
{
	switch(seqg_trn)
	{
	case 0:
		{
			/* C code definitions */
# line 441 "./../sncSeqRAM.stt"
			 
# line 444 "./../sncSeqRAM.stt"
			seqen = 1;
# line 445 "./../sncSeqRAM.stt"
			seq_pvPutTmo(seqg_env, 6/*seqen*/, SYNC, DEFAULT_TIMEOUT);
# line 448 "./../sncSeqRAM.stt"
			seqsw = 1;
# line 449 "./../sncSeqRAM.stt"
			seq_pvPutTmo(seqg_env, 7/*seqsw*/, SYNC, DEFAULT_TIMEOUT);
# line 451 "./../sncSeqRAM.stt"
			printf("Write succeded: seqen=%d, seqs=%d\n", seqen, seqs);
		}
		return;
	case 1:
		{
# line 457 "./../sncSeqRAM.stt"
			printf("Going from CheckSeq1Write to Running State\n");
			 
# line 461 "./../sncSeqRAM.stt"
			printf("Moving to Running State\n");
		}
		return;
	case 2:
		{
			/* C code definitions */
# line 466 "./../sncSeqRAM.stt"
			 
# line 468 "./../sncSeqRAM.stt"
			printf("CheckSeq1Write: Unseccessful Write to Seq1, going to Stopped State\n");
# line 472 "./../sncSeqRAM.stt"
			printf("Error: Write to SeqRAM 1 Failed.\n");
		}
		return;
	}
}

/****** Code for state "Running" in state set "seq" ******/

/* Entry function for state "Running" in state set "seq" */
static void seqg_entry_seq_0_Running(SS_ID seqg_env)
{
	/* C code definitions */
# line 481 "./../sncSeqRAM.stt"
	





       
# line 490 "./../sncSeqRAM.stt"
	StateMachineStatus = 2;
# line 491 "./../sncSeqRAM.stt"
	seq_pvPutTmo(seqg_env, 0/*StateMachineStatus*/, SYNC, DEFAULT_TIMEOUT);
# line 494 "./../sncSeqRAM.stt"
	seq_efClear(seqg_env, stopFlag);
# line 495 "./../sncSeqRAM.stt"
	seq_efClear(seqg_env, injFlag);
# line 496 "./../sncSeqRAM.stt"
	seq_efClear(seqg_env, restFlag);
# line 499 "./../sncSeqRAM.stt"
	numberOfWrites = 0;
# line 501 "./../sncSeqRAM.stt"
	printf("Running Entry\n");
}

/* Event function for state "Running" in state set "seq" */
static seqBool seqg_event_seq_0_Running(SS_ID seqg_env, int *seqg_ptrn, int *seqg_pnst)
{
# line 504 "./../sncSeqRAM.stt"
	if (seq_efTestAndClear(seqg_env, stopFlag) && stop_tg)
	{
		*seqg_pnst = 3;
		*seqg_ptrn = 0;
		return TRUE;
	}
# line 515 "./../sncSeqRAM.stt"
	if (seqs == 0)
	{
		*seqg_pnst = 1;
		*seqg_ptrn = 1;
		return TRUE;
	}
# line 522 "./../sncSeqRAM.stt"
	if (seq_efTestAndClear(seqg_env, injFlag) && inj_tg)
	{
		*seqg_pnst = 4;
		*seqg_ptrn = 2;
		return TRUE;
	}
# line 547 "./../sncSeqRAM.stt"
	if (seqs == 2)
	{
		*seqg_pnst = 5;
		*seqg_ptrn = 3;
		return TRUE;
	}
# line 554 "./../sncSeqRAM.stt"
	if (seq_efTestAndClear(seqg_env, restFlag) && restart_tg)
	{
		*seqg_pnst = 6;
		*seqg_ptrn = 4;
		return TRUE;
	}
	return FALSE;
}

/* Action function for state "Running" in state set "seq" */
static void seqg_action_seq_0_Running(SS_ID seqg_env, int seqg_trn, int *seqg_pnst)
{
	switch(seqg_trn)
	{
	case 0:
		{
			/* C code definitions */
# line 506 "./../sncSeqRAM.stt"
			 
# line 509 "./../sncSeqRAM.stt"
			seqen = 0;
# line 510 "./../sncSeqRAM.stt"
			seq_pvPutTmo(seqg_env, 6/*seqen*/, SYNC, DEFAULT_TIMEOUT);
# line 512 "./../sncSeqRAM.stt"
			printf("Stop Triggered\n");
		}
		return;
	case 1:
		{
			/* C code definitions */
# line 517 "./../sncSeqRAM.stt"
			 
# line 519 "./../sncSeqRAM.stt"
			printf("Moving to Stopped State\n");
		}
		return;
	case 2:
		{
			/* C code definitions */
# line 524 "./../sncSeqRAM.stt"
			



    
# line 531 "./../sncSeqRAM.stt"
			StateMachineStatus = 7;
# line 532 "./../sncSeqRAM.stt"
			seq_pvPutTmo(seqg_env, 0/*StateMachineStatus*/, SYNC, DEFAULT_TIMEOUT);
# line 535 "./../sncSeqRAM.stt"
			seq_pvGetTmo(seqg_env, 2/*tbl*/, SYNC, DEFAULT_TIMEOUT);
# line 538 "./../sncSeqRAM.stt"
			seq_pvGetTmo(seqg_env, 3/*tbl_length*/, SYNC, DEFAULT_TIMEOUT);
# line 542 "./../sncSeqRAM.stt"
			numberOfWrites = seqTwoWrite(expandedEventNum, tbl, tbl_length, ssId, &seqaddr, &seqcode, &seqtime, &seqcount, seq_pvIndex(seqg_env, 8/*seqaddr*/), seq_pvIndex(seqg_env, 9/*seqcode*/), seq_pvIndex(seqg_env, 10/*seqtime*/), seq_pvIndex(seqg_env, 11/*seqcount*/));
# line 544 "./../sncSeqRAM.stt"
			printf("Injection Triggered\n");
		}
		return;
	case 3:
		{
			/* C code definitions */
# line 549 "./../sncSeqRAM.stt"
			 
# line 551 "./../sncSeqRAM.stt"
			printf("Moving to Injecting State\n");
		}
		return;
	case 4:
		{
			/* C code definitions */
# line 556 "./../sncSeqRAM.stt"
			 
# line 558 "./../sncSeqRAM.stt"
			printf("Moving to Restarting State\n");
		}
		return;
	}
}

/****** Code for state "CheckSeq2Write" in state set "seq" ******/

/* Entry function for state "CheckSeq2Write" in state set "seq" */
static void seqg_entry_seq_0_CheckSeq2Write(SS_ID seqg_env)
{
	/* C code definitions */
# line 566 "./../sncSeqRAM.stt"
	

       
# line 570 "./../sncSeqRAM.stt"
	printf("CheckSeq2Write Entry\n");
}

/* Event function for state "CheckSeq2Write" in state set "seq" */
static seqBool seqg_event_seq_0_CheckSeq2Write(SS_ID seqg_env, int *seqg_ptrn, int *seqg_pnst)
{
# line 573 "./../sncSeqRAM.stt"
	if (seqcount == numberOfWrites)
	{
		*seqg_pnst = 4;
		*seqg_ptrn = 0;
		return TRUE;
	}
# line 586 "./../sncSeqRAM.stt"
	if (seqs == 2)
	{
		*seqg_pnst = 5;
		*seqg_ptrn = 1;
		return TRUE;
	}
# line 593 "./../sncSeqRAM.stt"
	if (seq_delay(seqg_env, 5.0) && seqs != 2)
	{
		*seqg_pnst = 3;
		*seqg_ptrn = 2;
		return TRUE;
	}
	return FALSE;
}

/* Action function for state "CheckSeq2Write" in state set "seq" */
static void seqg_action_seq_0_CheckSeq2Write(SS_ID seqg_env, int seqg_trn, int *seqg_pnst)
{
	switch(seqg_trn)
	{
	case 0:
		{
			/* C code definitions */
# line 575 "./../sncSeqRAM.stt"
			 
# line 578 "./../sncSeqRAM.stt"
			numberOfWrites = -1;
# line 581 "./../sncSeqRAM.stt"
			seqsw = 1;
# line 582 "./../sncSeqRAM.stt"
			seq_pvPutTmo(seqg_env, 7/*seqsw*/, SYNC, DEFAULT_TIMEOUT);
		}
		return;
	case 1:
		{
			/* C code definitions */
# line 588 "./../sncSeqRAM.stt"
			 
# line 590 "./../sncSeqRAM.stt"
			printf("Moving to Injecting State\n");
		}
		return;
	case 2:
		{
			/* C code definitions */
# line 595 "./../sncSeqRAM.stt"
			 
# line 600 "./../sncSeqRAM.stt"
			printf("Error: Write to SeqRAM 2 Failed.\n");
		}
		return;
	}
}

/****** Code for state "Injecting" in state set "seq" ******/

/* Entry function for state "Injecting" in state set "seq" */
static void seqg_entry_seq_0_Injecting(SS_ID seqg_env)
{
	/* C code definitions */
# line 608 "./../sncSeqRAM.stt"
	




       
# line 616 "./../sncSeqRAM.stt"
	StateMachineStatus = 3;
# line 617 "./../sncSeqRAM.stt"
	seq_pvPutTmo(seqg_env, 0/*StateMachineStatus*/, SYNC, DEFAULT_TIMEOUT);
# line 620 "./../sncSeqRAM.stt"
	seq_efClear(seqg_env, stopFlag);
# line 622 "./../sncSeqRAM.stt"
	printf("Injecting Entry\n");
}

/* Event function for state "Injecting" in state set "seq" */
static seqBool seqg_event_seq_0_Injecting(SS_ID seqg_env, int *seqg_ptrn, int *seqg_pnst)
{
# line 625 "./../sncSeqRAM.stt"
	if (seqs == 1)
	{
		*seqg_pnst = 3;
		*seqg_ptrn = 0;
		return TRUE;
	}
# line 632 "./../sncSeqRAM.stt"
	if (seq_efTestAndClear(seqg_env, stopInjFlag) && stopinj_tg)
	{
		*seqg_pnst = 5;
		*seqg_ptrn = 1;
		return TRUE;
	}
# line 645 "./../sncSeqRAM.stt"
	if (seq_efTestAndClear(seqg_env, stopFlag) && stop_tg)
	{
		*seqg_pnst = 5;
		*seqg_ptrn = 2;
		return TRUE;
	}
# line 656 "./../sncSeqRAM.stt"
	if (seqs == 0)
	{
		*seqg_pnst = 1;
		*seqg_ptrn = 3;
		return TRUE;
	}
	return FALSE;
}

/* Action function for state "Injecting" in state set "seq" */
static void seqg_action_seq_0_Injecting(SS_ID seqg_env, int seqg_trn, int *seqg_pnst)
{
	switch(seqg_trn)
	{
	case 0:
		{
			/* C code definitions */
# line 627 "./../sncSeqRAM.stt"
			 
# line 629 "./../sncSeqRAM.stt"
			printf("Moving to Running State\n");
		}
		return;
	case 1:
		{
			/* C code definitions */
# line 634 "./../sncSeqRAM.stt"
			 
# line 637 "./../sncSeqRAM.stt"
			if (seqs == 2)
			{
# line 638 "./../sncSeqRAM.stt"
				seqsw = 1;
# line 639 "./../sncSeqRAM.stt"
				seq_pvPutTmo(seqg_env, 7/*seqsw*/, SYNC, DEFAULT_TIMEOUT);
			}
# line 642 "./../sncSeqRAM.stt"
			printf("Stop Inj Triggered\n");
		}
		return;
	case 2:
		{
			/* C code definitions */
# line 647 "./../sncSeqRAM.stt"
			 
# line 650 "./../sncSeqRAM.stt"
			seqen = 0;
# line 651 "./../sncSeqRAM.stt"
			seq_pvPutTmo(seqg_env, 6/*seqen*/, SYNC, DEFAULT_TIMEOUT);
# line 653 "./../sncSeqRAM.stt"
			printf("Stop Triggered\n");
		}
		return;
	case 3:
		{
			/* C code definitions */
# line 658 "./../sncSeqRAM.stt"
			 
# line 660 "./../sncSeqRAM.stt"
			printf("Moving to Stopped State\n");
		}
		return;
	}
}

/****** Code for state "Restarting" in state set "seq" ******/

/* Entry function for state "Restarting" in state set "seq" */
static void seqg_entry_seq_0_Restarting(SS_ID seqg_env)
{
	/* C code definitions */
# line 668 "./../sncSeqRAM.stt"
	






       
# line 678 "./../sncSeqRAM.stt"
	StateMachineStatus = 4;
# line 679 "./../sncSeqRAM.stt"
	seq_pvPutTmo(seqg_env, 0/*StateMachineStatus*/, SYNC, DEFAULT_TIMEOUT);
# line 682 "./../sncSeqRAM.stt"
	seqen = 0;
# line 683 "./../sncSeqRAM.stt"
	seq_pvPutTmo(seqg_env, 6/*seqen*/, SYNC, DEFAULT_TIMEOUT);
# line 686 "./../sncSeqRAM.stt"
	for (i = 0; i < eventNum; i++)
	{
# line 688 "./../sncSeqRAM.stt"
		seq_pvGetTmo(seqg_env, 12/*event_codes*/ + (CH_ID)(i), SYNC, DEFAULT_TIMEOUT);
# line 689 "./../sncSeqRAM.stt"
		seq_pvGetTmo(seqg_env, 32/*event_timestamps*/ + (CH_ID)(i), SYNC, DEFAULT_TIMEOUT);
# line 690 "./../sncSeqRAM.stt"
		seq_pvGetTmo(seqg_env, 52/*event_modes*/ + (CH_ID)(i), SYNC, DEFAULT_TIMEOUT);
# line 691 "./../sncSeqRAM.stt"
		seq_pvGetTmo(seqg_env, 72/*event_ctrl*/ + (CH_ID)(i), SYNC, DEFAULT_TIMEOUT);
	}
# line 695 "./../sncSeqRAM.stt"
	updateEventPointerArray(eventNum, event_codes, event_timestamps, event_modes, event_ctrl);
# line 699 "./../sncSeqRAM.stt"
	expandedEventNum = updateExpandedArray(train_enable, train_start_time, train_pulse_size, train_pulse_cnt, train_pulse_code, eventNum);
# line 702 "./../sncSeqRAM.stt"
	numberOfWrites = 0;
# line 704 "./../sncSeqRAM.stt"
	printf("Restarting Entry\n");
}

/* Event function for state "Restarting" in state set "seq" */
static seqBool seqg_event_seq_0_Restarting(SS_ID seqg_env, int *seqg_ptrn, int *seqg_pnst)
{
# line 707 "./../sncSeqRAM.stt"
	if (seqs == 0 && seqen_rbv == 0)
	{
		*seqg_pnst = 2;
		*seqg_ptrn = 0;
		return TRUE;
	}
# line 717 "./../sncSeqRAM.stt"
	if (seqs == 1 && seqen != 0)
	{
		*seqg_pnst = 3;
		*seqg_ptrn = 1;
		return TRUE;
	}
	return FALSE;
}

/* Action function for state "Restarting" in state set "seq" */
static void seqg_action_seq_0_Restarting(SS_ID seqg_env, int seqg_trn, int *seqg_pnst)
{
	switch(seqg_trn)
	{
	case 0:
		{
			/* C code definitions */
# line 709 "./../sncSeqRAM.stt"
			 
# line 712 "./../sncSeqRAM.stt"
			numberOfWrites = seqOneWrite(expandedEventNum, ssId, &seqaddr, &seqcode, &seqtime, &seqcount, seq_pvIndex(seqg_env, 8/*seqaddr*/), seq_pvIndex(seqg_env, 9/*seqcode*/), seq_pvIndex(seqg_env, 10/*seqtime*/), seq_pvIndex(seqg_env, 11/*seqcount*/));
		}
		return;
	case 1:
		{
			/* C code definitions */
# line 719 "./../sncSeqRAM.stt"
			 
# line 721 "./../sncSeqRAM.stt"
			printf("Moving to Running State\n");
		}
		return;
	}
}

/****** Code for state "checking" in state set "reset_tg_pv" ******/

/* Event function for state "checking" in state set "reset_tg_pv" */
static seqBool seqg_event_reset_tg_pv_1_checking(SS_ID seqg_env, int *seqg_ptrn, int *seqg_pnst)
{
# line 729 "./../sncSeqRAM.stt"
	if (stop_pv && seq_delay(seqg_env, 1.5))
	{
		*seqg_pnst = 0;
		*seqg_ptrn = 0;
		return TRUE;
	}
# line 735 "./../sncSeqRAM.stt"
	if (run_pv && seq_delay(seqg_env, 1.5))
	{
		*seqg_pnst = 0;
		*seqg_ptrn = 1;
		return TRUE;
	}
# line 741 "./../sncSeqRAM.stt"
	if (stopinj_pv && seq_delay(seqg_env, 1.5))
	{
		*seqg_pnst = 0;
		*seqg_ptrn = 2;
		return TRUE;
	}
# line 747 "./../sncSeqRAM.stt"
	if (inj_pv && seq_delay(seqg_env, 1.5))
	{
		*seqg_pnst = 0;
		*seqg_ptrn = 3;
		return TRUE;
	}
# line 753 "./../sncSeqRAM.stt"
	if (restart_pv && seq_delay(seqg_env, 1.5))
	{
		*seqg_pnst = 0;
		*seqg_ptrn = 4;
		return TRUE;
	}
# line 759 "./../sncSeqRAM.stt"
	if (update_pv && seq_delay(seqg_env, 1.5))
	{
		*seqg_pnst = 0;
		*seqg_ptrn = 5;
		return TRUE;
	}
	return FALSE;
}

/* Action function for state "checking" in state set "reset_tg_pv" */
static void seqg_action_reset_tg_pv_1_checking(SS_ID seqg_env, int seqg_trn, int *seqg_pnst)
{
	switch(seqg_trn)
	{
	case 0:
		{
			/* C code definitions */
# line 730 "./../sncSeqRAM.stt"
			 
# line 731 "./../sncSeqRAM.stt"
			stop_pv = 0;
# line 732 "./../sncSeqRAM.stt"
			seq_pvPutTmo(seqg_env, 92/*stop_pv*/, SYNC, DEFAULT_TIMEOUT);
		}
		return;
	case 1:
		{
			/* C code definitions */
# line 736 "./../sncSeqRAM.stt"
			 
# line 737 "./../sncSeqRAM.stt"
			run_pv = 0;
# line 738 "./../sncSeqRAM.stt"
			seq_pvPutTmo(seqg_env, 96/*run_pv*/, SYNC, DEFAULT_TIMEOUT);
		}
		return;
	case 2:
		{
			/* C code definitions */
# line 742 "./../sncSeqRAM.stt"
			 
# line 743 "./../sncSeqRAM.stt"
			stopinj_pv = 0;
# line 744 "./../sncSeqRAM.stt"
			seq_pvPutTmo(seqg_env, 94/*stopinj_pv*/, SYNC, DEFAULT_TIMEOUT);
		}
		return;
	case 3:
		{
			/* C code definitions */
# line 748 "./../sncSeqRAM.stt"
			 
# line 749 "./../sncSeqRAM.stt"
			inj_pv = 0;
# line 750 "./../sncSeqRAM.stt"
			seq_pvPutTmo(seqg_env, 98/*inj_pv*/, SYNC, DEFAULT_TIMEOUT);
		}
		return;
	case 4:
		{
			/* C code definitions */
# line 754 "./../sncSeqRAM.stt"
			 
# line 755 "./../sncSeqRAM.stt"
			restart_pv = 0;
# line 756 "./../sncSeqRAM.stt"
			seq_pvPutTmo(seqg_env, 100/*restart_pv*/, SYNC, DEFAULT_TIMEOUT);
		}
		return;
	case 5:
		{
			/* C code definitions */
# line 760 "./../sncSeqRAM.stt"
			 
# line 761 "./../sncSeqRAM.stt"
			update_pv = 0;
# line 762 "./../sncSeqRAM.stt"
			seq_pvPutTmo(seqg_env, 102/*update_pv*/, SYNC, DEFAULT_TIMEOUT);
		}
		return;
	}
}

#undef seqg_var

/************************ Tables ************************/

/* Channel table */
static seqChan seqg_chans[] = {
	/* chName, offset, varName, varType, count, eventNum, efId, monitored, queueSize, queueIndex */
	{"{device}:STATEMACHINE", (size_t)&StateMachineStatus, "StateMachineStatus", P_INT, 1, 7, 0, 0, 0, 0},
	{"{device}:network", (size_t)&network, "network", P_INT, 1, 8, 0, 1, 0, 0},
	{"{device}:ITBL", (size_t)&tbl, "tbl", P_INT, 2000, 9, 0, 0, 0, 0},
	{"{device}:ITBL.NORD", (size_t)&tbl_length, "tbl_length", P_INT, 1, 10, 0, 0, 0, 0},
	{"{device}:seqstat", (size_t)&seqs, "seqs", P_INT, 1, 11, 0, 1, 0, 0},
	{"{device}:seqenRBV", (size_t)&seqen_rbv, "seqen_rbv", P_INT, 1, 12, 0, 1, 0, 0},
	{"{device}:seqen", (size_t)&seqen, "seqen", P_INT, 1, 13, 0, 0, 0, 0},
	{"{device}:seqram_switch.PROC", (size_t)&seqsw, "seqsw", P_INT, 1, 14, 0, 0, 0, 0},
	{"{device}:seqaddr", (size_t)&seqaddr, "seqaddr", P_INT, 1, 15, 0, 0, 0, 0},
	{"{device}:seqcode", (size_t)&seqcode, "seqcode", P_INT, 1, 16, 0, 0, 0, 0},
	{"{device}:seqtime", (size_t)&seqtime, "seqtime", P_INT, 1, 17, 0, 0, 0, 0},
	{"{device}:seqcountRBV", (size_t)&seqcount, "seqcount", P_INT, 1, 18, 0, 1, 0, 0},
	{"", (size_t)&event_codes[0], "event_codes[0]", P_INT, 1, 19, 0, 0, 0, 0},
	{"", (size_t)&event_codes[1], "event_codes[1]", P_INT, 1, 20, 0, 0, 0, 0},
	{"", (size_t)&event_codes[2], "event_codes[2]", P_INT, 1, 21, 0, 0, 0, 0},
	{"", (size_t)&event_codes[3], "event_codes[3]", P_INT, 1, 22, 0, 0, 0, 0},
	{"", (size_t)&event_codes[4], "event_codes[4]", P_INT, 1, 23, 0, 0, 0, 0},
	{"", (size_t)&event_codes[5], "event_codes[5]", P_INT, 1, 24, 0, 0, 0, 0},
	{"", (size_t)&event_codes[6], "event_codes[6]", P_INT, 1, 25, 0, 0, 0, 0},
	{"", (size_t)&event_codes[7], "event_codes[7]", P_INT, 1, 26, 0, 0, 0, 0},
	{"", (size_t)&event_codes[8], "event_codes[8]", P_INT, 1, 27, 0, 0, 0, 0},
	{"", (size_t)&event_codes[9], "event_codes[9]", P_INT, 1, 28, 0, 0, 0, 0},
	{"", (size_t)&event_codes[10], "event_codes[10]", P_INT, 1, 29, 0, 0, 0, 0},
	{"", (size_t)&event_codes[11], "event_codes[11]", P_INT, 1, 30, 0, 0, 0, 0},
	{"", (size_t)&event_codes[12], "event_codes[12]", P_INT, 1, 31, 0, 0, 0, 0},
	{"", (size_t)&event_codes[13], "event_codes[13]", P_INT, 1, 32, 0, 0, 0, 0},
	{"", (size_t)&event_codes[14], "event_codes[14]", P_INT, 1, 33, 0, 0, 0, 0},
	{"", (size_t)&event_codes[15], "event_codes[15]", P_INT, 1, 34, 0, 0, 0, 0},
	{"", (size_t)&event_codes[16], "event_codes[16]", P_INT, 1, 35, 0, 0, 0, 0},
	{"", (size_t)&event_codes[17], "event_codes[17]", P_INT, 1, 36, 0, 0, 0, 0},
	{"", (size_t)&event_codes[18], "event_codes[18]", P_INT, 1, 37, 0, 0, 0, 0},
	{"", (size_t)&event_codes[19], "event_codes[19]", P_INT, 1, 38, 0, 0, 0, 0},
	{"", (size_t)&event_timestamps[0], "event_timestamps[0]", P_INT, 1, 39, 0, 0, 0, 0},
	{"", (size_t)&event_timestamps[1], "event_timestamps[1]", P_INT, 1, 40, 0, 0, 0, 0},
	{"", (size_t)&event_timestamps[2], "event_timestamps[2]", P_INT, 1, 41, 0, 0, 0, 0},
	{"", (size_t)&event_timestamps[3], "event_timestamps[3]", P_INT, 1, 42, 0, 0, 0, 0},
	{"", (size_t)&event_timestamps[4], "event_timestamps[4]", P_INT, 1, 43, 0, 0, 0, 0},
	{"", (size_t)&event_timestamps[5], "event_timestamps[5]", P_INT, 1, 44, 0, 0, 0, 0},
	{"", (size_t)&event_timestamps[6], "event_timestamps[6]", P_INT, 1, 45, 0, 0, 0, 0},
	{"", (size_t)&event_timestamps[7], "event_timestamps[7]", P_INT, 1, 46, 0, 0, 0, 0},
	{"", (size_t)&event_timestamps[8], "event_timestamps[8]", P_INT, 1, 47, 0, 0, 0, 0},
	{"", (size_t)&event_timestamps[9], "event_timestamps[9]", P_INT, 1, 48, 0, 0, 0, 0},
	{"", (size_t)&event_timestamps[10], "event_timestamps[10]", P_INT, 1, 49, 0, 0, 0, 0},
	{"", (size_t)&event_timestamps[11], "event_timestamps[11]", P_INT, 1, 50, 0, 0, 0, 0},
	{"", (size_t)&event_timestamps[12], "event_timestamps[12]", P_INT, 1, 51, 0, 0, 0, 0},
	{"", (size_t)&event_timestamps[13], "event_timestamps[13]", P_INT, 1, 52, 0, 0, 0, 0},
	{"", (size_t)&event_timestamps[14], "event_timestamps[14]", P_INT, 1, 53, 0, 0, 0, 0},
	{"", (size_t)&event_timestamps[15], "event_timestamps[15]", P_INT, 1, 54, 0, 0, 0, 0},
	{"", (size_t)&event_timestamps[16], "event_timestamps[16]", P_INT, 1, 55, 0, 0, 0, 0},
	{"", (size_t)&event_timestamps[17], "event_timestamps[17]", P_INT, 1, 56, 0, 0, 0, 0},
	{"", (size_t)&event_timestamps[18], "event_timestamps[18]", P_INT, 1, 57, 0, 0, 0, 0},
	{"", (size_t)&event_timestamps[19], "event_timestamps[19]", P_INT, 1, 58, 0, 0, 0, 0},
	{"", (size_t)&event_modes[0], "event_modes[0]", P_INT, 1, 59, 0, 0, 0, 0},
	{"", (size_t)&event_modes[1], "event_modes[1]", P_INT, 1, 60, 0, 0, 0, 0},
	{"", (size_t)&event_modes[2], "event_modes[2]", P_INT, 1, 61, 0, 0, 0, 0},
	{"", (size_t)&event_modes[3], "event_modes[3]", P_INT, 1, 62, 0, 0, 0, 0},
	{"", (size_t)&event_modes[4], "event_modes[4]", P_INT, 1, 63, 0, 0, 0, 0},
	{"", (size_t)&event_modes[5], "event_modes[5]", P_INT, 1, 64, 0, 0, 0, 0},
	{"", (size_t)&event_modes[6], "event_modes[6]", P_INT, 1, 65, 0, 0, 0, 0},
	{"", (size_t)&event_modes[7], "event_modes[7]", P_INT, 1, 66, 0, 0, 0, 0},
	{"", (size_t)&event_modes[8], "event_modes[8]", P_INT, 1, 67, 0, 0, 0, 0},
	{"", (size_t)&event_modes[9], "event_modes[9]", P_INT, 1, 68, 0, 0, 0, 0},
	{"", (size_t)&event_modes[10], "event_modes[10]", P_INT, 1, 69, 0, 0, 0, 0},
	{"", (size_t)&event_modes[11], "event_modes[11]", P_INT, 1, 70, 0, 0, 0, 0},
	{"", (size_t)&event_modes[12], "event_modes[12]", P_INT, 1, 71, 0, 0, 0, 0},
	{"", (size_t)&event_modes[13], "event_modes[13]", P_INT, 1, 72, 0, 0, 0, 0},
	{"", (size_t)&event_modes[14], "event_modes[14]", P_INT, 1, 73, 0, 0, 0, 0},
	{"", (size_t)&event_modes[15], "event_modes[15]", P_INT, 1, 74, 0, 0, 0, 0},
	{"", (size_t)&event_modes[16], "event_modes[16]", P_INT, 1, 75, 0, 0, 0, 0},
	{"", (size_t)&event_modes[17], "event_modes[17]", P_INT, 1, 76, 0, 0, 0, 0},
	{"", (size_t)&event_modes[18], "event_modes[18]", P_INT, 1, 77, 0, 0, 0, 0},
	{"", (size_t)&event_modes[19], "event_modes[19]", P_INT, 1, 78, 0, 0, 0, 0},
	{"", (size_t)&event_ctrl[0], "event_ctrl[0]", P_INT, 1, 79, 0, 0, 0, 0},
	{"", (size_t)&event_ctrl[1], "event_ctrl[1]", P_INT, 1, 80, 0, 0, 0, 0},
	{"", (size_t)&event_ctrl[2], "event_ctrl[2]", P_INT, 1, 81, 0, 0, 0, 0},
	{"", (size_t)&event_ctrl[3], "event_ctrl[3]", P_INT, 1, 82, 0, 0, 0, 0},
	{"", (size_t)&event_ctrl[4], "event_ctrl[4]", P_INT, 1, 83, 0, 0, 0, 0},
	{"", (size_t)&event_ctrl[5], "event_ctrl[5]", P_INT, 1, 84, 0, 0, 0, 0},
	{"", (size_t)&event_ctrl[6], "event_ctrl[6]", P_INT, 1, 85, 0, 0, 0, 0},
	{"", (size_t)&event_ctrl[7], "event_ctrl[7]", P_INT, 1, 86, 0, 0, 0, 0},
	{"", (size_t)&event_ctrl[8], "event_ctrl[8]", P_INT, 1, 87, 0, 0, 0, 0},
	{"", (size_t)&event_ctrl[9], "event_ctrl[9]", P_INT, 1, 88, 0, 0, 0, 0},
	{"", (size_t)&event_ctrl[10], "event_ctrl[10]", P_INT, 1, 89, 0, 0, 0, 0},
	{"", (size_t)&event_ctrl[11], "event_ctrl[11]", P_INT, 1, 90, 0, 0, 0, 0},
	{"", (size_t)&event_ctrl[12], "event_ctrl[12]", P_INT, 1, 91, 0, 0, 0, 0},
	{"", (size_t)&event_ctrl[13], "event_ctrl[13]", P_INT, 1, 92, 0, 0, 0, 0},
	{"", (size_t)&event_ctrl[14], "event_ctrl[14]", P_INT, 1, 93, 0, 0, 0, 0},
	{"", (size_t)&event_ctrl[15], "event_ctrl[15]", P_INT, 1, 94, 0, 0, 0, 0},
	{"", (size_t)&event_ctrl[16], "event_ctrl[16]", P_INT, 1, 95, 0, 0, 0, 0},
	{"", (size_t)&event_ctrl[17], "event_ctrl[17]", P_INT, 1, 96, 0, 0, 0, 0},
	{"", (size_t)&event_ctrl[18], "event_ctrl[18]", P_INT, 1, 97, 0, 0, 0, 0},
	{"", (size_t)&event_ctrl[19], "event_ctrl[19]", P_INT, 1, 98, 0, 0, 0, 0},
	{"{device}:STOPSEQ", (size_t)&stop_pv, "stop_pv", P_INT, 1, 99, 0, 1, 0, 0},
	{"{device}:STOP_TG.PROC", (size_t)&stop_tg, "stop_tg", P_INT, 1, 100, 1, 1, 0, 0},
	{"{device}:STOPINJSEQ", (size_t)&stopinj_pv, "stopinj_pv", P_INT, 1, 101, 0, 1, 0, 0},
	{"{device}:STOPINJ_TG.PROC", (size_t)&stopinj_tg, "stopinj_tg", P_INT, 1, 102, 2, 1, 0, 0},
	{"{device}:RUNSEQ", (size_t)&run_pv, "run_pv", P_INT, 1, 103, 0, 1, 0, 0},
	{"{device}:RUN_TG.PROC", (size_t)&run_tg, "run_tg", P_INT, 1, 104, 3, 1, 0, 0},
	{"{device}:INJSEQ", (size_t)&inj_pv, "inj_pv", P_INT, 1, 105, 0, 1, 0, 0},
	{"{device}:INJ_TG.PROC", (size_t)&inj_tg, "inj_tg", P_INT, 1, 106, 4, 1, 0, 0},
	{"{device}:RESTSEQ", (size_t)&restart_pv, "restart_pv", P_INT, 1, 107, 0, 1, 0, 0},
	{"{device}:RESTART_TG.PROC", (size_t)&restart_tg, "restart_tg", P_INT, 1, 108, 5, 1, 0, 0},
	{"{device}:UPDATEEV", (size_t)&update_pv, "update_pv", P_INT, 1, 109, 0, 1, 0, 0},
	{"{device}:UPDATE_TG.PROC", (size_t)&update_tg, "update_tg", P_INT, 1, 110, 6, 1, 0, 0},
	{"{device}:PTEN", (size_t)&train_enable, "train_enable", P_INT, 1, 111, 0, 1, 0, 0},
	{"{device}:PTCNT", (size_t)&train_pulse_cnt, "train_pulse_cnt", P_INT, 1, 112, 0, 1, 0, 0},
	{"{device}:PTSIZE", (size_t)&train_pulse_size, "train_pulse_size", P_INT, 1, 113, 0, 1, 0, 0},
	{"{device}:PTTIME", (size_t)&train_start_time, "train_start_time", P_INT, 1, 114, 0, 1, 0, 0},
	{"{device}:PTCODE", (size_t)&train_pulse_code, "train_pulse_code", P_INT, 1, 115, 0, 1, 0, 0},
};

/* Event masks for state set "seq" */
static const seqMask seqg_mask_seq_0_init[] = {
	0x00000900,
	0x00000000,
	0x00000000,
	0x00000000,
};
static const seqMask seqg_mask_seq_0_Stopped[] = {
	0x00041848,
	0x00000000,
	0x00000000,
	0x00004100,
};
static const seqMask seqg_mask_seq_0_CheckSeq1Write[] = {
	0x00041800,
	0x00000000,
	0x00000000,
	0x00000000,
};
static const seqMask seqg_mask_seq_0_Running[] = {
	0x00000832,
	0x00000000,
	0x00000000,
	0x00001410,
};
static const seqMask seqg_mask_seq_0_CheckSeq2Write[] = {
	0x00040800,
	0x00000000,
	0x00000000,
	0x00000000,
};
static const seqMask seqg_mask_seq_0_Injecting[] = {
	0x00000806,
	0x00000000,
	0x00000000,
	0x00000050,
};
static const seqMask seqg_mask_seq_0_Restarting[] = {
	0x00003800,
	0x00000000,
	0x00000000,
	0x00000000,
};

/* State table for state set "seq" */
static seqState seqg_states_seq[] = {
	{
	/* state name */        "init",
	/* action function */   seqg_action_seq_0_init,
	/* event function */    seqg_event_seq_0_init,
	/* entry function */    seqg_entry_seq_0_init,
	/* exit function */     0,
	/* event mask array */  seqg_mask_seq_0_init,
	/* state options */     (0)
	},
	{
	/* state name */        "Stopped",
	/* action function */   seqg_action_seq_0_Stopped,
	/* event function */    seqg_event_seq_0_Stopped,
	/* entry function */    seqg_entry_seq_0_Stopped,
	/* exit function */     0,
	/* event mask array */  seqg_mask_seq_0_Stopped,
	/* state options */     (0)
	},
	{
	/* state name */        "CheckSeq1Write",
	/* action function */   seqg_action_seq_0_CheckSeq1Write,
	/* event function */    seqg_event_seq_0_CheckSeq1Write,
	/* entry function */    seqg_entry_seq_0_CheckSeq1Write,
	/* exit function */     0,
	/* event mask array */  seqg_mask_seq_0_CheckSeq1Write,
	/* state options */     (0)
	},
	{
	/* state name */        "Running",
	/* action function */   seqg_action_seq_0_Running,
	/* event function */    seqg_event_seq_0_Running,
	/* entry function */    seqg_entry_seq_0_Running,
	/* exit function */     0,
	/* event mask array */  seqg_mask_seq_0_Running,
	/* state options */     (0)
	},
	{
	/* state name */        "CheckSeq2Write",
	/* action function */   seqg_action_seq_0_CheckSeq2Write,
	/* event function */    seqg_event_seq_0_CheckSeq2Write,
	/* entry function */    seqg_entry_seq_0_CheckSeq2Write,
	/* exit function */     0,
	/* event mask array */  seqg_mask_seq_0_CheckSeq2Write,
	/* state options */     (0)
	},
	{
	/* state name */        "Injecting",
	/* action function */   seqg_action_seq_0_Injecting,
	/* event function */    seqg_event_seq_0_Injecting,
	/* entry function */    seqg_entry_seq_0_Injecting,
	/* exit function */     0,
	/* event mask array */  seqg_mask_seq_0_Injecting,
	/* state options */     (0)
	},
	{
	/* state name */        "Restarting",
	/* action function */   seqg_action_seq_0_Restarting,
	/* event function */    seqg_event_seq_0_Restarting,
	/* entry function */    seqg_entry_seq_0_Restarting,
	/* exit function */     0,
	/* event mask array */  seqg_mask_seq_0_Restarting,
	/* state options */     (0)
	},
};

/* Event masks for state set "reset_tg_pv" */
static const seqMask seqg_mask_reset_tg_pv_1_checking[] = {
	0x00000000,
	0x00000000,
	0x00000000,
	0x00002aa8,
};

/* State table for state set "reset_tg_pv" */
static seqState seqg_states_reset_tg_pv[] = {
	{
	/* state name */        "checking",
	/* action function */   seqg_action_reset_tg_pv_1_checking,
	/* event function */    seqg_event_reset_tg_pv_1_checking,
	/* entry function */    0,
	/* exit function */     0,
	/* event mask array */  seqg_mask_reset_tg_pv_1_checking,
	/* state options */     (0)
	},
};

/* State set table */
static seqSS seqg_statesets[] = {
	{
	/* state set name */    "seq",
	/* states */            seqg_states_seq,
	/* number of states */  7
	},

	{
	/* state set name */    "reset_tg_pv",
	/* states */            seqg_states_reset_tg_pv,
	/* number of states */  1
	},
};

/* Program table (global) */
seqProgram sncSeqRAM = {
	/* magic number */      2002001,
	/* program name */      "sncSeqRAM",
	/* channels */          seqg_chans,
	/* num. channels */     109,
	/* state sets */        seqg_statesets,
	/* num. state sets */   2,
	/* user var size */     0,
	/* param */             "",
	/* num. event flags */  6,
	/* encoded options */   (0 | OPT_CONN | OPT_NEWEF),
	/* init func */         seqg_init,
	/* entry func */        0,
	/* exit func */         0,
	/* num. queues */       0
};
# line 771 "./../sncSeqRAM.stt"

# 781 "./../sncSeqRAM.stt"
 int str2int(char * str){

  int num = 0, i = 0;

  while(str[i] != '\0'){

   int aux = ch2int(str[i]);
   if(aux != -1){
    num *= 10;
    num += aux;
   }
   else{
    num = -1;
    break;
   }

   i++;
  }

  return num;
 }
# 812 "./../sncSeqRAM.stt"
 int ch2int(char ch){

  int num = 0;

  if(ch =='0')
   num = 0;
  else if(ch == '1')
   num = 1;
  else if(ch == '2')
   num = 2;
  else if(ch == '3')
   num = 3;
  else if(ch == '4')
   num = 4;
  else if(ch == '5')
   num = 5;
  else if(ch == '6')
   num = 6;
  else if(ch == '7')
   num = 7;
  else if(ch == '8')
   num = 8;
  else if(ch == '9')
   num = 9;
  else
   num = -1;

  return num;
 }
# 850 "./../sncSeqRAM.stt"
 void init_EventPointerArray(int size){

  int i;

  for(i = 0; i < size; i++){

   EventPointerArray[i] = &EventArray[i];
  }
 }
# 871 "./../sncSeqRAM.stt"
 int bubbleSort(Event* * evArray, int arraySize){

  int sorted = 0;
  int a, b;

  if(evArray == NULL){

   printf("Can't sort Event Array. Event array is null.\n");


   return 0;
  }


  for (a = 0; a < arraySize - 1; a++){

   sorted = 1;


   for (b = arraySize - 1; b > a; b--){


    if (evArray[b-1]->timestamp > evArray[b]->timestamp){

     swap(&evArray[b-1], &evArray[b]);
     sorted = 0;
    }


    if(evArray[b-1]->timestamp == evArray[b]->timestamp){

     evArray[b]->timestamp += 1;
     sorted = 0;
    }
   }


   if(sorted)
    break;
  }


  return 1;
 }
# 924 "./../sncSeqRAM.stt"
 void swap(Event* *a, Event* *b){

  Event * tmp;
  tmp = *a;
  *a = *b;
  *b = tmp;
 }
# 940 "./../sncSeqRAM.stt"
 void updateEventPointerArray(int evNumber, int * code_arr,
     int * time_arr, int * mode_arr, int * control_arr){

  int i;


  for(i = 0; i < evNumber; i++){

   EventPointerArray[i]->code = code_arr[i];
   EventPointerArray[i]->timestamp = time_arr[i];
   EventPointerArray[i]->mode = mode_arr[i];
   EventPointerArray[i]->ctrl = control_arr[i];
  }


  bubbleSort(EventPointerArray, evNumber);
 }
# 973 "./../sncSeqRAM.stt"
 int seqOneWrite(int evnum, SS_ID ssId, int *pseqaddr, int *pseqcode, int *pseqtime, int *pseqcount,
    VAR_ID seqaddr_id, VAR_ID seqcode_id, VAR_ID seqtime_id, VAR_ID seqcount_id){

  int i, maxdelay = 0, address = 0;


  int offSetEndCode = 10;

  for(i = 0; i < evnum; i++){


   if(ExpandedEventArray[i].ctrl != ALWAYS)
    continue;


   *pseqaddr = address;
   *pseqcode = ExpandedEventArray[i].code;
   *pseqtime = maxdelay = ExpandedEventArray[i].timestamp;


   seq_pvPut(ssId, seqaddr_id, SYNC);
   seq_pvPut(ssId, seqcode_id, SYNC);


   seq_pvPut(ssId, seqtime_id, SYNC);



   printf("Write to SeqRAM 1-> seqaddr= %d, seqcode= %d, seqtime= %d\n", *pseqaddr, *pseqcode, *pseqtime);




   address++;
  }




  *pseqaddr = address;
  *pseqcode = 0x7F;
  *pseqtime = maxdelay + offSetEndCode;


  seq_pvPut(ssId, seqaddr_id, SYNC);
  seq_pvPut(ssId, seqcode_id, SYNC);


  seq_pvPut(ssId, seqtime_id, SYNC);



  printf("Write to SeqRAM 1-> seqaddr= %d, seqcode= %d, seqtime= %d\n", *pseqaddr, *pseqcode, *pseqtime);





  address++;


       return address;
 }
# 1053 "./../sncSeqRAM.stt"
 int seqTwoWrite(int evnum, int TBL[], int length, SS_ID ssId, int *pseqaddr, int *pseqcode,
   int *pseqtime, int *pseqcount, VAR_ID seqaddr_id, VAR_ID seqcode_id, VAR_ID seqtime_id, VAR_ID seqcount_id){

  int i, j, seqdly, rfdly, maxdelay = 0, address = 0;


  int offSetEndCode = 10;


  int RFDlyTimestamp = 10;


  for(i = 0; i < length; i++){


   seqdly = TBL[i] / 4;
   rfdly = TBL[i] % 4;



   *pseqaddr = address;
   *pseqcode = 0x40 + rfdly * 5;
   *pseqtime = RFDlyTimestamp;


   seq_pvPut(ssId, seqaddr_id, SYNC);
   seq_pvPut(ssId, seqcode_id, SYNC);


   seq_pvPut(ssId, seqtime_id, SYNC);



   printf("Write to SeqRAM 2-> seqaddr= %d, seqcode= %d, seqtime= %d\n", *pseqaddr, *pseqcode, *pseqtime);





   address++;


   for(j = 0; j < evnum; j++){


    if(ExpandedEventArray[j].mode == INCR){


     *pseqtime = maxdelay = ExpandedEventArray[j].timestamp + seqdly;
    }
    else{


     *pseqtime = maxdelay = ExpandedEventArray[j].timestamp;
    }




    *pseqaddr = address;
    *pseqcode = ExpandedEventArray[j].code;


    seq_pvPut(ssId, seqaddr_id, SYNC);
    seq_pvPut(ssId, seqcode_id, SYNC);


    seq_pvPut(ssId, seqtime_id, SYNC);



    printf("Write to SeqRAM 2-> seqaddr= %d, seqcode= %d, seqtime= %d\n", *pseqaddr, *pseqcode, *pseqtime);





    address++;

   }


   if(i < length - 1){

    *pseqcode = 0x70;


    *pseqaddr = address;
    *pseqtime = maxdelay + offSetEndCode;


    seq_pvPut(ssId, seqaddr_id, SYNC);
    seq_pvPut(ssId, seqcode_id, SYNC);


    seq_pvPut(ssId, seqtime_id, SYNC);



    printf("Write to SeqRAM 2-> seqaddr= %d, seqcode= %d, seqtime= %d\n", *pseqaddr, *pseqcode, *pseqtime);





    address++;
   }
  }


  *pseqcode = 0x7E;


  *pseqaddr = address;
  *pseqtime = maxdelay + offSetEndCode;


  seq_pvPut(ssId, seqaddr_id, SYNC);
  seq_pvPut(ssId, seqcode_id, SYNC);


  seq_pvPut(ssId, seqtime_id, SYNC);



  printf("Write to SeqRAM 2-> seqaddr= %d, seqcode= %d, seqtime= %d\n", *pseqaddr, *pseqcode, *pseqtime);




  address++;


         return address;
 }
# 1200 "./../sncSeqRAM.stt"
 int expandArray(int evnum, int trainEnable, int pulseCnt, int trainDuration, int trainStart, int trainCode){

  int i, j;


  int expIndex = 0;


  int pulseInterval = trainDuration / pulseCnt;
  int pulseTime = trainStart;
  int pulsesLeft = 0;


  if(trainEnable == 0 || pulseCnt == 0){


   for(i = 0; i < evnum; i++){

    ExpandedEventArray[expIndex].code = EventPointerArray[i]->code;
    ExpandedEventArray[expIndex].timestamp = EventPointerArray[i]->timestamp;
    ExpandedEventArray[expIndex].mode = EventPointerArray[i]->mode;
    ExpandedEventArray[expIndex].ctrl = EventPointerArray[i]->ctrl;

    expIndex++;
   }


   return expIndex;
  }



  for(i = 0; i < evnum; i++){


   if(trainStart == pulseTime && EventPointerArray[i]->timestamp > trainStart){

    pulsesLeft = pulseCnt;
   }


   if(pulsesLeft > 0){



    int n = 0;

    if(pulseTime < EventPointerArray[i]->timestamp)
     n = floor((EventPointerArray[i]->timestamp - pulseTime) / pulseInterval) + 1;

    if(n > pulsesLeft) n = pulsesLeft;


    for(j = 0; j < n; j++){

     ExpandedEventArray[expIndex].code = trainCode;

     ExpandedEventArray[expIndex].timestamp = pulseTime;
     pulseTime += pulseInterval;

     ExpandedEventArray[expIndex].mode = INCR;
     ExpandedEventArray[expIndex].ctrl = ALWAYS;


     expIndex++;
    }


    pulsesLeft -= n;
   }


   ExpandedEventArray[expIndex].code = EventPointerArray[i]->code;
   ExpandedEventArray[expIndex].timestamp = EventPointerArray[i]->timestamp;
   ExpandedEventArray[expIndex].mode = EventPointerArray[i]->mode;
   ExpandedEventArray[expIndex].ctrl = EventPointerArray[i]->ctrl;


   expIndex++;
  }


  if(trainStart == pulseTime)
   pulsesLeft = pulseCnt;


  for(i = 0; i < pulsesLeft; i++){

   ExpandedEventArray[expIndex].code = trainCode;
   ExpandedEventArray[expIndex].timestamp = pulseTime;
   pulseTime += pulseInterval;
   ExpandedEventArray[expIndex].mode = INCR;
   ExpandedEventArray[expIndex].ctrl = ALWAYS;


   expIndex++;
  }


  return expIndex;
 }
# 1314 "./../sncSeqRAM.stt"
 int trainStartCorrection(int trainEnable, int trainStart, int trainDuration, int pulseCnt, int evnum) {

  if(!trainEnable) return trainStart;

  int i;

  int interval = trainDuration/pulseCnt;

      for(i = evnum-1; i >= 0; i--){

   int diff = EventPointerArray[i]->timestamp - trainStart;

   if(diff >= 0 && !(diff % interval))
    trainStart--;
  }


  if(trainStart < 0) trainStart = 0;


  return trainStart;
 }
# 1351 "./../sncSeqRAM.stt"
 int updateExpandedArray(int trainEnable, int trainStart, int trainDuration, int pulseCnt, int trainCode, int evnum){


  trainStart = trainStartCorrection(trainEnable, trainStart, trainDuration, pulseCnt, evnum);


  int newNumEvents = expandArray(evnum, trainEnable, pulseCnt, trainDuration, trainStart, trainCode);

  return newNumEvents;
 }


#define PROG_NAME sncSeqRAM
#include "seqMain.c"

/* Register sequencer commands and program */
#include "epicsExport.h"
static void sncSeqRAMRegistrar (void) {
    seqRegisterSequencerCommands();
    seqRegisterSequencerProgram (&sncSeqRAM);
}
epicsExportRegistrar(sncSeqRAMRegistrar);
